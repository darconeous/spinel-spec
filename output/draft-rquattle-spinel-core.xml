<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<rfc ipr="trust200902" category="std" docName="draft-rquattle-spinel-core-fa153f6">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="yes"?>
<?rfc private=""?>
<?rfc topblock="yes"?>
<?rfc comments="yes"?>
<front>
<title abbrev="Spinel Core">Spinel: A protocol for control and management of IPv6 network co-processors</title>

<author initials="R." surname="Quattlebaum" fullname="Robert S. Quattlebaum">
<organization>Nest Labs, Inc.</organization>
<address>
<postal>
<street>3400 Hillview Ave.</street>
<city>Palo Alto</city>
<code>94304</code>
<country>USA</country>
<region>California</region>
</postal>
<phone></phone>
<email>rquattle@nestlabs.com</email>
<uri></uri>
</address>
</author>
<author role="editor" initials="j.h." surname="woodyatt" fullname="james woodyatt">
<organization>Nest Labs, Inc.</organization>
<address>
<postal>
<street>3400 Hillview Ave.</street>
<city>Palo Alto</city>
<code>94304</code>
<country>USA</country>
<region>California</region>
</postal>
<phone></phone>
<email>jhw@nestlabs.com</email>
<uri></uri>
</address>
</author>
<date year="2017" month="October" day="30"/>

<area>Internet</area>
<workgroup></workgroup>
<keyword>Spinel</keyword>
<keyword>IPv6</keyword>
<keyword>NCP</keyword>


<abstract>
<t>This document specifies the core of the Spinel host-controller
protocol, which enables a general purpose application processor to
manage, control, and offload IPv6 network functions to a Network
Co-Processor (NCP) connected via a simple communication link(such as
UART, SPI, or USB).
</t>
<t>Spinel was initially designed for use with Thread(R) network
co-processors, but the core of the protocol is general purpose and
intended to be easily adapted to other types of low-power IPv6
networking technologies.
</t>
</abstract>


</front>

<middle>

<section anchor="introduction" title="Introduction">
<t>IEEE 802.15.4 based low-power wireless networks are quickly becoming
ubiquitous, and with the introduction of 6LoWPAN<xref target="RFC4944"/>,
IPv6<xref target="RFC8200"/> connectivity is now possible on these networks.
6LoWPAN-based network technologies such as Thread(R) and ZigBee(R) IP
additionally provide additional features such as network security,
mesh-networking, and ultra-low-power operation. To fully realize
low-power operation, a great deal of the IPv6 network and routing
stack needs to be implemented directly on a NCP (Network
Co-Processor). With that, we again find ourselves with a question of
how best to communicate with and manage this new class of peripheral.
</t>
<t>The problem of needing to communicate with and manage an NCP is not
new: However, the current existing and proposed approaches have severe
drawbacks (See <xref target="appendix-comparison"/>).
</t>
<t>Spinel is a host-controller protocol designed to address the drawbacks
of existing protocols and lower implementation and deployment burdens
by providing a standardized mechanism for the management and control
of IPv6-based NCPs by general purpose device operating systems (OS).
</t>

<section anchor="objectives" title="Objectives">
<t>Spinel was designed to satisfy the following objectives:
</t>
<t>
<list style="numbers">
<t>The protocol must allow for managing the network interface at the
network layer.</t>
<t>The protocol must allow for multiple data streams, including IPv6
traffic, debug messages, and raw sniffed traffic.</t>
<t>The protocol must be link agnostic: should work efficiently over
UART, SPI, USB or other busses and links.</t>
<t>The protocol must be relatively straightforward to understand and
implement.</t>
<t>The protocol must gracefully handle the addition of new features
and capabilities without necessarily breaking backward
compatibility.</t>
<t>The protocol must support multiple conceptually independent
network interfaces.</t>
<t>The protocol must be reasonably compact and lightweight.</t>
</list>
</t>
<t>Beyond this core framework, properties and commands enable various
common features of IPv6. In related and forthcoming documents, the
Spinel protocol is extended to support NCP implementations for
specific IPv6 link types, e.g. Thread(R).
</t>
</section>

<section anchor="terminology" title="Terminology">
<t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>The layout diagrams in this document that show encodings of data in
octet sequences use the convention described in Guide for Internet
Standards Writers <xref target="RFC2360"/> section 3.1, Packet Diagrams.
Specifically, bits in octets are indexed from most significant to
least significant, and the least significant bit in a field
representing an integer value more than one bit in length is the least
significant bit of a the signed or unsigned number, as the case
requires.
</t>
<t>The term &quot;byte&quot; is used in its now-customary sense as a synonym for
&quot;octet&quot;.  All multi-byte values are encoded in network byte order
(that is, most significant byte first, also known as &quot;big-endian&quot;).
</t>
<t>This specification makes use of the following terminology:
</t>
<t><cref source="RQ">Alphabetize before finalization.</cref></t>
<t>
<list style="hanging">
<t hangText="FCS">
<vspace />
Final Checksum. Octets added to the end of a packet to help determine if the packet was received without corruption.</t>
<t hangText="NCP">
<vspace />
Network Control Processor.</t>
<t hangText="NLI">
<vspace />
Network Link Identifier. May be a value between zero and three. See <xref target="nli-network-link-identifier"/> for more information.</t>
<t hangText="OS">
<vspace />
Operating System, i.e. the IPv6 node using Spinel to control and manage one or more of its IPv6 network interfaces.</t>
<t hangText="PHY">
<vspace />
Physical layer. Refers to characteristics and parameters related to the physical implementation and operation of a networking medium.</t>
<t hangText="PUI">
<vspace />
Packed Unsigned Integer. A way to serialize an unsigned integer using one, two, or three octets. Used throughout the Spinel protocol. See <xref target="packed-unsigned-integer"/> for more information.</t>
<t hangText="TID">
<vspace />
Transaction Identifier. May be a value between zero and fifteen. See <xref target="tid-transaction-identifier"/> for more information.</t>
</list>
</t>
</section>
</section>

<section anchor="property-overview" title="Property Overview">
<t>Spinel is largely a property-based protocol. The NCP exposes various
properties that the host can manipulate to control its behavior. The
theory of operation is similar to representational state transfer
(REST)(TODO:CITE), with a property defined for every attribute of the operational
state of a network interface for which an IPv6 node may need the
typical operators, i.e. Create, Read, Update, Delete and Alert.
</t>
<t>The inspiration of the approach used in Spinel was the concept of
hardware registers for peripherals. The goal was to avoid, as much as
possible, the use of large complicated structures and/or method
argument lists. The reason for avoiding these is because they have a
tendency to change in incompatible ways, especially early in
development. For example, adding or removing an argument from a
command will render the entire protocol incompatible. By using
properties and conforming to a well-designed information model,
extending the protocol is usually as simple as an additional property.
</t>
<t>Almost all features and capabilities are implemented using properties.
Most new features that are initially proposed as explicit commands can
be satisfactorily adapted to be property-based instead. In cases where
doing so is particularly awkward, explicit commands are used instead
(See <xref target="commands"/>).
</t>
<t>Properties are identified by a unique unsigned integer value between 0
and 2,097,151 (See <xref target="packed-unsigned-integer"/>) called a &quot;property
key&quot;. Property keys are recorded in the Spinel property key registry
(EDITOR: proposal is to create an IANA registry) with some ranges
already reserved for future expansion of the core and other ranges
available for profile specialization.
</t>
<t>What follows is a overview of how properties work.
</t>

<section anchor="property-operators" title="Property Operators">
<t>Conceptually, the following operations are used by the OS to query or change a property's value:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">VALUE_GET</spanx></t>
<t><spanx style="verb">VALUE_SET</spanx></t>
<t><spanx style="verb">VALUE_INSERT</spanx></t>
<t><spanx style="verb">VALUE_REMOVE</spanx></t>
</list>
</t>
<t>In addition, the following operations can be used by the NCP to indicate changes to the value of a property:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">VALUE_IS</spanx></t>
<t><spanx style="verb">VALUE_INSERTED</spanx></t>
<t><spanx style="verb">VALUE_REMOVED</spanx></t>
</list>
</t>
<t>Not all properties support all of the above operations. Which operations are supported is generally determined by two things: what type of property it is and that property's readability/writability.
</t>
</section>

<section anchor="property-types" title="Property Types">
<t>Conceptually, there are three different types of properties:
</t>
<t>
<list style="symbols">
<t>Single-value properties</t>
<t>Multiple-value (Array) properties</t>
<t>Stream properties</t>
</list>
</t>
<t>These are described in further detail in the following sections.
</t>

<section anchor="singlevalue-properties" title="Single-Value Properties">
<t>Single-value properties are properties that have a simple representation of a single value. Examples would be:
</t>
<t>
<list style="symbols">
<t>Current radio channel (Represented as a unsigned 8-bit integer)</t>
<t>Network name (Represented as a UTF-8 encoded string)</t>
<t>802.15.4 PAN ID (Represented as a unsigned 16-bit integer)</t>
</list>
</t>
<t>The valid operators on these sorts of properties are <spanx style="verb">VALUE_GET</spanx> and <spanx style="verb">VALUE_SET</spanx>.
</t>
</section>

<section anchor="multiplevalue-properties" title="Multiple-Value Properties">
<t>Multiple-Value Properties have more than one value associated with them. Examples would be:
</t>
<t>
<list style="symbols">
<t>List of channels supported by the radio hardware.</t>
<t>List of IPv6 addresses assigned to the interface.</t>
<t>List of capabilities supported by the NCP.</t>
</list>
</t>
<t>The valid operators on these sorts of properties are <spanx style="verb">VALUE_GET</spanx>, <spanx style="verb">VALUE_SET</spanx>, <spanx style="verb">VALUE_INSERT</spanx>, and <spanx style="verb">VALUE_REMOVE</spanx>.
</t>
<t>When the value is fetched using <spanx style="verb">VALUE_GET</spanx>, an individual property will return the entire list of items as either of the following:
</t>
<t>
<list style="numbers">
<t>The concatenation of all of the individual values. This is used in cases where the length of an individual item is fixed.</t>
<t>The concatenation of all of the individual values, each prefixed by a 16-bit big-endian integer describing the length of the individual item. This would be used in cases where the length of an individual item is not constant.</t>
</list>
</t>
<t>The order of the returned items, unless explicitly defined for that specific property, is undefined.
</t>
<t><spanx style="verb">VALUE_SET</spanx> provides a way to completely replace all previous values, with the item format matching what would be used for <spanx style="verb">VALUE_GET</spanx>. Calling <spanx style="verb">VALUE_SET</spanx> with an empty value effectively instructs the NCP to empty that property.
</t>
<t><spanx style="verb">VALUE_INSERT</spanx> and <spanx style="verb">VALUE_REMOVE</spanx> provide mechanisms for the insertion or removal of individual items <spanx style="emph">by value</spanx>. The payload for these operators is a single item.
</t>
</section>

<section anchor="stream-properties" title="Stream Properties">
<t>Stream properties represent dynamic streams of data rather than a specific value. Examples would be:
</t>
<t>
<list style="symbols">
<t>Network packet stream (<xref target="prop-stream-net"/>)</t>
<t>Raw packet stream (<xref target="prop-stream-raw"/>)</t>
<t>Debug message stream (<xref target="prop-stream-debug"/>)</t>
</list>
</t>
<t>All such properties emit changes asynchronously using the <spanx style="verb">VALUE_IS</spanx> operator, sent from the NCP to the OS. For example, as IPv6 traffic is received by the NCP, the IPv6 packets are sent to the OS by way of asynchronous <spanx style="verb">VALUE_IS</spanx> operations for the network packet stream property.
</t>
<t>Some of these properties also support the OS sending data back to the NCP using the <spanx style="verb">VALUE_SET</spanx> operation. For example, this is how the OS sends IPv6 traffic to the NCP.
</t>
<t>The behavior and meaning of the <spanx style="verb">VALUE_GET</spanx>, <spanx style="verb">VALUE_INSERT</spanx>, <spanx style="verb">VALUE_REMOVE</spanx>, <spanx style="verb">VALUE_INSERTED</spanx>, and <spanx style="verb">VALUE_REMOVED</spanx> operations for stream properties is undefined and SHOULD NOT be used.
</t>
</section>
</section>
</section>

<section anchor="spinel-frames" title="Spinel Frames">
<t>Spinel is a frame-based (rather than stream-based) protocol. Frames
can be of any size between two bytes and MTU of the channel (which is
RECOMMENDED to be at least 1300 bytes). Spinel frames SHALL be
delivered reliably and in-order.
</t>
<t>The mechanism responsible for transporting frames between the OS and
the NCP (while also ensuring both reliable and in-order delivery) is
called the <spanx style="emph">framing mechanism</spanx>. While Spinel does not mandate any
specific framing mechanism be used, this document does make detailed
recommendations in <xref target="appendix-framing"/>. This layered approach privides
a great deal of implementation flexibility.
</t>

<section anchor="frame-format" title="Frame Format">
<t>A Spinel frame is the concatenation of the following elements:
</t>
<t>
<list style="symbols">
<t>A header comprising a single octet (see <xref target="header-format"/> below).</t>
<t>A command identifier (up to three octets, see
<xref target="packed-unsigned-integer"/> for format)</t>
<t>An optional command payload (Contents of which are defined by the
specific command being sent)</t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD</c><c>CMD_PAYLOAD</c>
</texttable>
<t>For example, each of the property operations described in the previous
section is defined as a specific command identifier with the property
key as the first part of the payload. Additional commands are defined
for special purposes (see <xref target="commands"/>), and the command identifier
registry has values reserved for future standard expansion,
application specialization, and experimental purposes.
</t>
</section>

<section anchor="header-format" title="Header Format">
<t>The header comprises the following information elements packed into a
single octet:
</t>

<figure align="center"><artwork align="center">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|  FLG  |  NLI  |      TID      |
+---+---+---+---+---+---+---+---+
</artwork></figure>
<t><cref source="RQ">Eventually, when https://github.com/miekg/mmark/issues/95
is addressed, the above table should be swapped out with this:

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|---|---|---|---|---|---|---|---|
|  FLG ||  NLI ||      TID   ||||</cref></t>

<section anchor="flg-flag" title="FLG: Flag">
<t>The Flag (FLG) field in the two most significant bits of the header
octet (<spanx style="verb">FLG</spanx>) is always set to the value two (or <spanx style="verb">10</spanx> in binary). Any
frame received with these bits set to any other value SHALL NOT be
considered a Spinel frame.
</t>
<t>This convention allows Spinel to be line compatible with BTLE HCI. By
defining the first two bit in this way we can disambiguate between
Spinel frames and HCI frames (which always start with either <spanx style="verb">0x01</spanx> or
<spanx style="verb">0x04</spanx>) without any additional framing overhead.
</t>
</section>

<section anchor="nli-network-link-identifier" title="NLI: Network Link Identifier">
<t>The Network Link Identifier (NLI) field is used to distinguish between
independent &quot;virtual&quot; network links. It is stored in the third and
fourth most significant bits as a number between 0 and 3.
</t>
<t>The NLI field allows for the control and management of an NCP that can
be connected to more than one network simultaneously, as if multiple
independent NCPs were present. The exact implementation of such
capability is outside the scope of this document.
</t>
<t>All NCPs conforming to this protocol SHALL implement NLI 0 and MAY
provide additional network interfaces via NLI values 1, 2, and 3.
</t>
<t>Any commands sent to an unimplemented NLI MUST fail with
<spanx style="verb">STATUS_UNIMPLEMENTED</spanx>.
</t>
</section>

<section anchor="tid-transaction-identifier" title="TID: Transaction Identifier">
<t>The Transaction Identifier (TID) field in the four least significant
bits of the header is used for correlating responses to the commands
which generated them.
</t>
<t>When a command is sent from the OS, any reply to that command sent by
the NCP will use the same value for the TID. When the OS receives a
frame that matches the TID of the command it sent, it can easily
recognize that frame as the actual response to that command.
</t>
<t>The zero value of TID is used for commands to which a correlated
response is not expected or needed, such as for unsolicited update
commands sent to the OS from the NCP.
</t>
</section>

<section anchor="cmd-command-identifier" title="CMD: Command Identifier">
<t>The command identifier is a 21-bit unsigned integer encoded in up to
three octets using the packed unsigned integer format described in
<xref target="packed-unsigned-integer"/>. This encoding allows for up to 2,097,152
individual commands, with the first 127 commands represented as a
single octet. Command identifiers larger than 2,097,151 are explicitly
forbidden.
</t>
</section>

<section anchor="cmdpayload-command-payload" title="CMD_PAYLOAD: Command Payload">
<t>The command payload follows the command identifier in a Spinel frame,
containing the serialization of any arguments that the indicated
command may require. The exact composition of a command payload is
determined by the specific command identifier being used and MUST be
empty if the command has no arguments.
</t>
</section>
</section>
</section>

<section anchor="data-packing" title="Data Packing">
<t><spanx style="strong">NOTE</spanx>:
    This section will be removed from this draft shortly.
</t>
<t>Data serialization for properties is performed using a light-weight data packing format which was loosely inspired by <eref target="https://www.freedesktop.org/wiki/Software/dbus/">the D-Bus</eref> developed by the X Desktop Group.
</t>
<t>As with D-Bus, the Spinel data packing format also defines a terse modeling language for describing the format of data packed for interchange between the OS and the NCP. With Spinel, however, the modeling language is an optional notational convenience, mainly of use in protocol definitions. As most NCP programming environments are highly constrained, it is not necessary to implement a structured validating parser for Spinel packed data to implement the Spinel protocol.
</t>
<t>Goals:
</t>
<t>
<list style="symbols">
<t>Be lightweight and favor direct representation of values.</t>
<t>Support lists and structures.</t>
<t>Allow fields to be appended to structures while maintaining backward compatibility.</t>
<t>Use an easily readable and memorable language for data modeling.</t>
</list>
</t>
<t>The Spinel data packing format is a method of encoding and decoding several &quot;primitive&quot; types of scalar data, e.g. fixed width integers, fixed-size network addresses, et cetera, and some simple aggregate types, i.e. arrays of a specific type, structures with fields of varying type, Unicode text strings.
</t>
<t>Each primitive datatype has an ASCII character associated with it in the corresponding modeling language. Fields in structures are identified by their position. The data model for any encoding of the Spinel data packing format can be represented as a strings of modeling language characters characters. These strings are called &quot;type signatures&quot; and some examples follow:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">C</spanx>: An unsigned integer encoded as a single octet.</t>
<t><spanx style="verb">C6U</spanx>: An unsigned integer encoded as a single octet, followed by a 128-but IPv6 address, followed by a Unicode text string.</t>
</list>
</t>
<t>In each case, the data is represented exactly as described. For example, an array of 10 IPv6 address is stored as 160 octets.
</t>

<section anchor="primitive-types" title="Primitive Types">
<texttable>
<ttcol align="center">Char</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Description</ttcol>

<c><spanx style="verb">.</spanx></c><c>DATATYPE_VOID</c><c>Empty data type. Used internally.</c>
<c><spanx style="verb">b</spanx></c><c>DATATYPE_BOOL</c><c>Boolean value. Encoded in 8-bits as either 0x00 or 0x01. All other values are illegal.</c>
<c><spanx style="verb">C</spanx></c><c>DATATYPE_UINT8</c><c>Unsigned 8-bit integer.</c>
<c><spanx style="verb">c</spanx></c><c>DATATYPE_INT8</c><c>Signed 8-bit integer.</c>
<c><spanx style="verb">S</spanx></c><c>DATATYPE_UINT16</c><c>Unsigned 16-bit integer.</c>
<c><spanx style="verb">s</spanx></c><c>DATATYPE_INT16</c><c>Signed 16-bit integer.</c>
<c><spanx style="verb">L</spanx></c><c>DATATYPE_UINT32</c><c>Unsigned 32-bit integer.</c>
<c><spanx style="verb">l</spanx></c><c>DATATYPE_INT32</c><c>Signed 32-bit integer.</c>
<c><spanx style="verb">i</spanx></c><c>DATATYPE_UINT_PACKED</c><c>Packed Unsigned Integer. See <xref target="packed-unsigned-integer"/>.</c>
<c><spanx style="verb">6</spanx></c><c>DATATYPE_IPv6ADDR</c><c>IPv6 Address. (Big-endian)</c>
<c><spanx style="verb">E</spanx></c><c>DATATYPE_EUI64</c><c>EUI-64 Address. (Big-endian)</c>
<c><spanx style="verb">e</spanx></c><c>DATATYPE_EUI48</c><c>EUI-48 Address. (Big-endian)</c>
<c><spanx style="verb">D</spanx></c><c>DATATYPE_DATA</c><c>Arbitrary data. See <xref target="data-blobs"/>.</c>
<c><spanx style="verb">d</spanx></c><c>DATATYPE_DATA_WLEN</c><c>Arbitrary data with prepended length. See <xref target="data-blobs"/>.</c>
<c><spanx style="verb">U</spanx></c><c>DATATYPE_UTF8</c><c>A text string encoded in UTF8 and terminated by a trailing zero byte.</c>
<c><spanx style="verb">t(...)</spanx></c><c>DATATYPE_STRUCT</c><c>Structured datatype with prepended length. See <xref target="structured-data"/>.</c>
<c><spanx style="verb">A(...)</spanx></c><c>DATATYPE_ARRAY</c><c>Array of datatypes. Compound type. See <xref target="arrays"/>.</c>
</texttable>
<t>All multi-octet values are little-endian unless explicitly stated otherwise.
</t>
</section>

<section anchor="packed-unsigned-integer" title="Packed Unsigned Integer">
<t>Certain types of integers, such as command or property identifiers, usually have a value on the wire that is less than 127. However, in order to not preclude the use of values larger than 255, we would need to add an extra octet. Doing this would add an extra octet to the majority of instances, which can add up in terms of bandwidth.
</t>
<t>The packed unsigned integer format is based on the <eref target="https://www.w3.org/TR/exi/#encodingUnsignedInteger">unsigned integer format in EXI</eref>, except that we limit the maximum value to the largest value that can be encoded to three octets o(2,097,151).
</t>
<t>For all values less than 127, the packed form of the number is simply a single octet which directly represents the number. For values larger than 127, the following process is used to encode the value:
</t>
<t>
<list style="numbers">
<t>The unsigned integer is broken up into <spanx style="emph">n</spanx> 7-bit chunks and placed into <spanx style="emph">n</spanx> octets, leaving the most significant bit of each octet unused.</t>
<t>Order the octets from least-significant to most-significant. (Little-endian)</t>
<t>Clear the most significant bit of the most significant octet. Set the least significant bit on all other octets.</t>
</list>
</t>
<t>Where <spanx style="emph">n</spanx> is the smallest number of 7-bit chunks you can use to
represent the given value.
</t>
<t>Take the value 1337, for example:
</t>

<figure align="center"><artwork align="center">
1337 =&gt; 0x0539
     =&gt; [39 0A]
     =&gt; [B9 0A]
</artwork></figure>
<t>To decode the value, you collect the 7-bit chunks until you find an octet with the most significant bit clear.
</t>
</section>

<section anchor="data-blobs" title="Data Blobs">
<t>There are two types for data blobs: <spanx style="verb">d</spanx> and <spanx style="verb">D</spanx>.
</t>
<t>
<list style="symbols">
<t><spanx style="verb">d</spanx> has the length of the data (in octets) prepended to the data (with the length encoded as type <spanx style="verb">S</spanx>). The size of the length field is not included in the length.</t>
<t><spanx style="verb">D</spanx> does not have a prepended length: the length of the data is implied by the octets remaining to be parsed. It is an error for <spanx style="verb">D</spanx> to not be the last type in a type in a type signature.</t>
</list>
</t>
<t>This dichotomy allows for more efficient encoding by eliminating redundancy. If the rest of the frame is a data blob, encoding the length would be redundant because we already know how many octets are in the rest of the frame.
</t>
<t>In some cases we use <spanx style="verb">d</spanx> even if it is the last field in a type signature. We do this to allow for us to be able to append additional fields to the type signature if necessary in the future. This is usually the case with embedded structs, like in the scan results.
</t>
<t>For example, let's say we have a buffer that is encoded with the datatype signature of <spanx style="verb">CLLD</spanx>. In this case, it is pretty easy to tell where the start and end of the data blob is: the start is 9 octets from the start of the buffer, and its length is the length of the buffer minus 9. (9 is the number of octets taken up by a octet and two longs)
</t>
<t>The datatype signature <spanx style="verb">CLLDU</spanx> is illegal because we can't determine where the last field (a zero-terminated UTF8 string) starts. But the datatype <spanx style="verb">CLLdU</spanx> <spanx style="emph">is</spanx> legal, because the parser can determine the exact length of the data blob-- allowing it to know where the start of the next field would be.
</t>
</section>

<section anchor="structured-data" title="Structured Data">
<t>The structure data type (<spanx style="verb">t(...)</spanx>) is a way of bundling together several fields into a single structure. It can be thought of as a <spanx style="verb">d</spanx> type except that instead of being opaque, the fields in the content are known and the parsing frame for the type signature bounded by the <spanx style="verb">(</spanx> and <spanx style="verb">)</spanx> characters is limited by the length of the structure in octets. This is useful for things like scan results where you have substructures which are defined by different layers. The limiting constraint of the length of the structure allowed the type signature of the structure contents to end in <spanx style="verb">D</spanx> to signify a data blob of implied length.
</t>
<t>For example, consider the type signature <spanx style="verb">Lt(ES)t(6D)</spanx>. In this hypothetical case, the first struct is defined by the MAC layer, and the second struct is defined by the PHY layer. Because of the use of structures, we know exactly what part comes from that layer. Additionally, we can add fields to each structure without introducing backward compatability problems: Data encoded as <spanx style="verb">Lt(ESU)t(6D)</spanx> (Notice the extra <spanx style="verb">U</spanx>) will decode just fine as <spanx style="verb">Lt(ES)t(6D)</spanx>. Additionally, if we don't care about the MAC layer and only care about the network layer, we could parse as <spanx style="verb">Lt()t(6D)</spanx>.
</t>
<t>Note that data encoded as <spanx style="verb">Lt(ES)t(6D)</spanx> will also parse as <spanx style="verb">Ldd</spanx>, with the structures from both layers now being opaque data blobs.
</t>
</section>

<section anchor="arrays" title="Arrays">
<t>An array is simply a concatenated set of <spanx style="emph">n</spanx> data encodings. For example, the type <spanx style="verb">A(6)</spanx> is simply a list of IPv6 addresses---one after the other. The type <spanx style="verb">A(6E)</spanx> likewise a concatenation of IPv6-address/EUI-64 pairs.
</t>
<t>If an array contains many fields, the fields will often be surrounded by a structure (<spanx style="verb">t(...)</spanx>). This effectively prepends each item in the array with its length. This is useful for improving parsing performance or to allow additional fields to be added in the future in a backward compatible way. If there is a high certainty that additional fields will never be added, the struct may be omitted (saving two octets per item).
</t>
<t>This specification does not define a way to embed an array as a field alongside other fields.
</t>
</section>
</section>

<section anchor="commands" title="Commands">
<t>This section defines the standard commands used in all Spinel protocol interactions. Each command is defined for one of the following two contexts:
</t>
<t>
<list style="symbols">
<t>OS -&gt; NCP: commands sent by the operating system (OS) to the network control processor (NCP).</t>
<t>NCP -&gt; OS: commands sent by the network control processor (NCP) to the operating system (OS).</t>
</list>
</t>
<t>A conforming implementation MAY transmit any command defined for its operating context, and MUST process any command received for its operating context, according to the operational semantics defined in this section.
</t>
<t>IANA maintains a registry of Spinel <spanx style="verb">CMD</spanx> command numbers, with varying registration policies assigned for different ranges according to the following table:
</t>
<texttable>
<ttcol align="center">CMD Number</ttcol>
<ttcol align="center">Reservation policy</ttcol>

<c>0 - 63</c><c>Standards Action</c>
<c>64 - 15,359</c><c>Unassigned</c>
<c>15,360 - 16,383</c><c>Private Use</c>
<c>16,384 - 1,999,999</c><c>Unassigned</c>
<c>2,000,000 - 2,097,151</c><c>Experimental Use</c>
</texttable>

<section anchor="cmd-noop" title="CMD 0: (OS -&gt; NCP) CMD_NOOP">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_NOOP</c>
</texttable>
<t>No-Operation. Commands the NCP to reply with a <spanx style="verb">STATUS_OK</spanx> code. This is primarily used for liveliness checks.
</t>
<t>The command payload for this command SHOULD be empty. The receiver MUST ignore any non-empty command payload.
</t>
<t>There is no error condition for this command.
</t>
</section>

<section anchor="cmd-reset" title="CMD 1: (OS -&gt; NCP) CMD_RESET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_RESET</c>
</texttable>
<t>Reset NCP. Commands the NCP to perform a software reset. Due to the nature of this command, the TID is ignored. The OS should instead wait for a <spanx style="verb">CMD_PROP_VALUE_IS</spanx> command from the NCP indicating <spanx style="verb">PROP_LAST_STATUS</spanx> has been set to <spanx style="verb">STATUS_RESET_SOFTWARE</spanx> (see <xref target="status-codes"/>).
</t>
<t>The command payload SHOULD be empty, and it SHOULD NOT be processed.
</t>
<t>If an error occurs, the value of the emitted <spanx style="verb">PROP_LAST_STATUS</spanx> will be set accordingly to the status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-get" title="CMD 2: (OS -&gt; NCP) CMD_PROP_VALUE_GET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_GET</c><c>PROP_ID</c>
</texttable>
<t>Get property value. Commands the NCP to emit a <spanx style="verb">CMD_PROP_VALUE_IS</spanx> command for the given property identifier.
</t>
<t>The payload for this command is the property identifier encoded in the packed unsigned integer format described in <xref target="packed-unsigned-integer"/>.
</t>
<t>If an error occurs, the value of the emitted <spanx style="verb">PROP_LAST_STATUS</spanx> will be set accordingly to the status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-set" title="CMD 3: (OS -&gt; NCP) CMD_PROP_VALUE_SET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_SET</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Set property value. Commands the NCP to set the given property to the specific given value, replacing any previous value, and to emit a <spanx style="verb">CMD_PROP_VALUE_IS</spanx> command for the <spanx style="verb">PROP_LAST_STATUS</spanx> command indicating <spanx style="verb">STATUS_OK</spanx> if successful.
</t>
<t>The payload for this command is the property identifier encoded in the packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by the property value. The exact format of the property value is defined by the property.
</t>
<t>If an error occurs, the value of the emitted <spanx style="verb">PROP_LAST_STATUS</spanx> will be set accordingly to the status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-insert" title="CMD 4: (OS -&gt; NCP) CMD_PROP_VALUE_INSERT">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_INSERT</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Insert value into list property. Commands the NCP to insert the given value into a list-oriented property, without removing other items in the list. The resulting order of items in the list is defined by the individual property being operated on.
</t>
<t>The payload for this command is the property identifier encoded in the packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by the value to be inserted. The exact format of the value is defined by the property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>) rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically, the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This helps to eliminate redundant data.
</t>
<t>If an error occurs, the value of the emitted <spanx style="verb">PROP_LAST_STATUS</spanx> will be set accordingly to the status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-remove" title="CMD 5: (OS -&gt; NCP) CMD_PROP_VALUE_REMOVE">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_REMOVE</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Remove value from list property. Commands the NCP to remove the given value from a list-oriented property, without affecting other items in the list. The resulting order of items in the list is defined by the individual property being operated on.
</t>
<t>Note that this command operates <spanx style="emph">by value</spanx>, not by index!
</t>
<t>The payload for this command is the property identifier encoded in the packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by the value to be removed. The exact format of the value is defined by the property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>) rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically, the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This helps to eliminate redundant data.
</t>
<t>If an error occurs, the value of the emitted <spanx style="verb">PROP_LAST_STATUS</spanx> will be set accordingly to the status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-is" title="CMD 6: (NCP -&gt; OS) CMD_PROP_VALUE_IS">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_IS</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Property value notification. This command can be sent by the NCP in response to a previous command from the OS, or it can be sent by the NCP in an unsolicited fashion to notify the OS of various state changes asynchronously.
</t>
<t>The payload for this command is the property identifier encoded in the packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by the current value of the given property.
</t>
</section>

<section anchor="cmd-prop-value-inserted" title="CMD 7: (NCP -&gt; OS) CMD_PROP_VALUE_INSERTED">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_INSERTED</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Property value insertion notification. This command can be sent by the NCP in response to the <spanx style="verb">CMD_PROP_VALUE_INSERT</spanx> command, or it can be sent by the NCP in an unsolicited fashion to notify the OS of various state changes asynchronously.
</t>
<t>The payload for this command is the property identifier encoded in the packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by the value that was inserted into the given property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>) rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically, the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This helps to eliminate redundant data.
</t>
<t>The resulting order of items in the list is defined by the given property.
</t>
</section>

<section anchor="cmd-prop-value-removed" title="CMD 8: (NCP -&gt; OS) CMD_PROP_VALUE_REMOVED">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_REMOVED</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Property value removal notification command. This command can be sent by the NCP in response to the <spanx style="verb">CMD_PROP_VALUE_REMOVE</spanx> command, or it can be sent by the NCP in an unsolicited fashion to notify the OS of various state changes asynchronously.
</t>
<t>Note that this command operates <spanx style="emph">by value</spanx>, not by index!
</t>
<t>The payload for this command is the property identifier encoded in the packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by the value that was removed from the given property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>) rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically, the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This helps to eliminate redundant data.
</t>
<t>The resulting order of items in the list is defined by the given property.
</t>
</section>

<section anchor="cmd-peek" title="CMD 18: (OS -&gt; NCP) CMD_PEEK">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">4</ttcol>
<ttcol align="center">2</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PEEK</c><c>ADDRESS</c><c>COUNT</c>
</texttable>
<t>This command allows the NCP to fetch values from the RAM of the NCP for debugging purposes. Upon success, <spanx style="verb">CMD_PEEK_RET</spanx> is sent from the NCP to the OS. Upon failure, <spanx style="verb">PROP_LAST_STATUS</spanx> is emitted with the appropriate error indication.
</t>
<t>Due to the low-level nature of this command, certain error conditions may induce the NCP to reset.
</t>
<t>The NCP MAY prevent certain regions of memory from being accessed.
</t>
<t>The implementation of this command has security implications. See <xref target="security-considerations"/> for more information.
</t>
<t>This command requires the capability <spanx style="verb">CAP_PEEK_POKE</spanx> to be present.
</t>
</section>

<section anchor="cmd-peek-ret" title="CMD 19: (NCP -&gt; OS) CMD_PEEK_RET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">4</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PEEK_RET</c><c>ADDRESS</c><c>COUNT</c><c>BYTES</c>
</texttable>
<t>This command contains the contents of memory that was requested by a previous call to <spanx style="verb">CMD_PEEK</spanx>.
</t>
<t>This command requires the capability <spanx style="verb">CAP_PEEK_POKE</spanx> to be present.
</t>
</section>

<section anchor="cmd-poke" title="CMD 20: (OS -&gt; NCP) CMD_POKE">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">4</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_POKE</c><c>ADDRESS</c><c>COUNT</c><c>BYTES</c>
</texttable>
<t>This command writes the bytes to the specified memory address for debugging purposes.
</t>
<t>Due to the low-level nature of this command, certain error conditions may induce the NCP to reset.
</t>
<t>The implementation of this command has security implications. See <xref target="security-considerations"/> for more information.
</t>
<t>This command requires the capability <spanx style="verb">CAP_PEEK_POKE</spanx> to be present.
</t>
</section>

<section anchor="cmd-prop-value-multi-get" title="CMD 21: (OS -&gt; NCP) CMD_PROP_VALUE_MULTI_GET">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">A(i)</spanx></t>
<t>Required Capability: <spanx style="verb">CAP_CMD_MULTI</spanx></t>
</list>
</t>
<t>Fetch the value of multiple properties in one command. Arguments are an array of property IDs. If all properties are fetched successfully, a <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> command is sent back to the OS containing the property identifier and value of each fetched property. The order of the results in <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> match the order of properties given in <spanx style="verb">CMD_PROP_VALUE_GET</spanx>.
</t>
<t>Errors fetching individual properties are reflected as indicating a change to <spanx style="verb">PROP_LAST_STATUS</spanx> for that property's place.
</t>
<t>Not all properties can be fetched using this method. As a general rule of thumb, any property that blocks when getting will fail for that individual property with <spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx>.
</t>
</section>

<section anchor="cmd-prop-value-multi-set" title="CMD 22: (OS -&gt; NCP) CMD_PROP_VALUE_MULTI_SET">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">A(iD)</spanx></t>
<t>Required Capability: <spanx style="verb">CAP_CMD_MULTI</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_MULTI_SET</c><c>Property/Value Pairs</c>
</texttable>
<t>With each property/value pair being:
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>LENGTH</c><c>PROP_ID</c><c>PROP_VALUE</c>
</texttable>
<t>This command sets the value of several properties at once in the given order. The setting of properties stops at the first error, ignoring any later properties.
</t>
<t>The result of this command is generally <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> unless (for example) a parsing error has occured (in which case <spanx style="verb">CMD_PROP_VALUE_IS</spanx> for <spanx style="verb">PROP_LAST_STATUS</spanx> would be the result). The order of the results in <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> match the order of properties given in <spanx style="verb">CMD_PROP_VALUE_MULTI_SET</spanx>.
</t>
<t>Since the processing of properties to set stops at the first error, the resulting <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> can contain fewer items than the requested number of properties to set.
</t>
<t>Not all properties can be set using this method. As a general rule of thumb, any property that blocks when setting will fail for that individual property with <spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx>.
</t>
</section>

<section anchor="cmd-prop-values-are" title="CMD 23: (NCP -&gt; OS) CMD_PROP_VALUES_ARE">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">A(iD)</spanx></t>
<t>Required Capability: <spanx style="verb">CAP_CMD_MULTI</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUES_ARE</c><c>Property/Value Pairs</c>
</texttable>
<t>With each property/value pair being:
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>LENGTH</c><c>PROP_ID</c><c>PROP_VALUE</c>
</texttable>
<t>This command is emitted by the NCP as the response to both the <spanx style="verb">CMD_PROP_VALUE_MULTI_GET</spanx> and <spanx style="verb">CMD_PROP_VALUE_MULTI_SET</spanx> commands. It is roughly analogous to <spanx style="verb">CMD_PROP_VALUE_IS</spanx>, except that it contains more than one property.
</t>
<t>This command SHOULD NOT be emitted asynchronously, or in response to any command other than <spanx style="verb">CMD_PROP_VALUE_MULTI_GET</spanx> or <spanx style="verb">CMD_PROP_VALUE_MULTI_SET</spanx>.
</t>
<t>The arguments are a list of structures containing the emitted property and the associated value. These are presented in the same order as given in the associated initiating command. In cases where getting or setting a specific property resulted in an error, the associated slot in this command will describe <spanx style="verb">PROP_LAST_STATUS</spanx>.
</t>
</section>
</section>

<section anchor="status-codes" title="Status Codes">
<t>Status codes are sent from the NCP to the OS via <spanx style="verb">PROP_LAST_STATUS</spanx> using the <spanx style="verb">CMD_VALUE_IS</spanx> command to indicate the return status of a previous command. As with any response, the TID field of the FLAG byte is used to correlate the response with the request.
</t>
<t>Note that most successfully executed commands do not indicate a last status of <spanx style="verb">STATUS_OK</spanx>. The usual way the NCP indicates a successful command is to mirror the property change back to the OS. For example, if you do a <spanx style="verb">CMD_VALUE_SET</spanx> on <spanx style="verb">PROP_PHY_ENABLED</spanx>, the NCP would indicate success by responding with a <spanx style="verb">CMD_VALUE_IS</spanx> for <spanx style="verb">PROP_PHY_ENABLED</spanx>. If the command failed, <spanx style="verb">PROP_LAST_STATUS</spanx> would be emitted instead.
</t>
<t>See <xref target="prop-last-status"/> for more information on <spanx style="verb">PROP_LAST_STATUS</spanx>.
</t>
<t>IANA maintains a registry of Spinel <spanx style="verb">STATUS_CODE</spanx> numbers, with varying registration policies assigned for different ranges according to the following table:
</t>
<texttable>
<ttcol align="left">Status Code Range</ttcol>
<ttcol align="left">Reservation Policy</ttcol>

<c>0 - 127</c><c>Standards Action</c>
<c>128 - 15,359</c><c>Unassigned</c>
<c>15,360 - 16,383</c><c>Private Use</c>
<c>16,384 - 1,999,999</c><c>Unassigned</c>
<c>2,000,000 - 2,097,151</c><c>Experimental Use</c>
</texttable>
<t>The Spinel core protoocol defines some standard status codes. Their names, assigned numbers and a short description of their operational semantics are shown in the following table:
</t>
<texttable>
<ttcol align="left">Code</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Description</ttcol>

<c>0</c><c><spanx style="verb">STATUS_OK</spanx></c><c>Operation has completed successfully.</c>
<c>1</c><c><spanx style="verb">STATUS_FAILURE</spanx></c><c>Operation has failed for an unspecified reason.</c>
<c>2</c><c><spanx style="verb">STATUS_UNIMPLEMENTED</spanx></c><c>The given operation has not been implemented.</c>
<c>3</c><c><spanx style="verb">STATUS_INVALID_ARGUMENT</spanx></c><c>An argument to the given operation is invalid.</c>
<c>4</c><c><spanx style="verb">STATUS_INVALID_STATE</spanx></c><c>The given operation is invalid for the current state of the device.</c>
<c>5</c><c><spanx style="verb">STATUS_INVALID_COMMAND</spanx></c><c>The given command is not recognized.</c>
<c>6</c><c><spanx style="verb">STATUS_INVALID_INTERFACE</spanx></c><c>The given network link identifier is not supported.</c>
<c>7</c><c><spanx style="verb">STATUS_INTERNAL_ERROR</spanx></c><c>An internal runtime error has occurred.</c>
<c>8</c><c><spanx style="verb">STATUS_SECURITY_ERROR</spanx></c><c>A security or authentication error has occurred.</c>
<c>9</c><c><spanx style="verb">STATUS_PARSE_ERROR</spanx></c><c>An error has occurred while parsing the command.</c>
<c>10</c><c><spanx style="verb">STATUS_IN_PROGRESS</spanx></c><c>An error has occurred while parsing the command.</c>
<c>11</c><c><spanx style="verb">STATUS_NOMEM</spanx></c><c>The operation has been prevented due to memory pressure.</c>
<c>12</c><c><spanx style="verb">STATUS_BUSY</spanx></c><c>The device is currently performing a mutually exclusive operation.</c>
<c>13</c><c><spanx style="verb">STATUS_PROP_NOT_FOUND</spanx></c><c>The given property is not recognized.</c>
<c>14</c><c><spanx style="verb">STATUS_PACKET_DROPPED</spanx></c><c>The packet was dropped.</c>
<c>15</c><c><spanx style="verb">STATUS_EMPTY</spanx></c><c>The result of the operation is empty.</c>
<c>16</c><c><spanx style="verb">STATUS_CMD_TOO_BIG</spanx></c><c>The command was too large to fit in the internal buffer.</c>
<c>17</c><c><spanx style="verb">STATUS_NO_ACK</spanx></c><c>The packet was not acknowledged.</c>
<c>18</c><c><spanx style="verb">STATUS_CCA_FAILURE</spanx></c><c>The packet was not sent due to a CCA failure.</c>
<c>19</c><c><spanx style="verb">STATUS_ALREADY</spanx></c><c>The operation is already in progress, or the property already has the value.</c>
<c>20</c><c><spanx style="verb">STATUS_ITEM_NOT_FOUND</spanx></c><c>The given item could not be found in the property.</c>
<c>21</c><c><spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx></c><c>The given command cannot be performed on this property.</c>
<c>??</c><c><spanx style="verb">STATUS_PROP_VALUE_TOO_BIG</spanx></c><c>The value fo this property is too large.</c>
<c>112</c><c><spanx style="verb">STATUS_RESET_POWER_ON</spanx></c><c>Cold power-on start.</c>
<c>113</c><c><spanx style="verb">STATUS_RESET_EXTERNAL</spanx></c><c>External device reset.</c>
<c>114</c><c><spanx style="verb">STATUS_RESET_SOFTWARE</spanx></c><c>Internal software orderly reset.</c>
<c>115</c><c><spanx style="verb">STATUS_RESET_FAULT</spanx></c><c>Internal software abortive reset.</c>
<c>116</c><c><spanx style="verb">STATUS_RESET_CRASH</spanx></c><c>Unrecoverable software execution failure.</c>
<c>117</c><c><spanx style="verb">STATUS_RESET_ASSERT</spanx></c><c>Software invariant property not respected.</c>
<c>118</c><c><spanx style="verb">STATUS_RESET_OTHER</spanx></c><c>Unspecified cause.</c>
<c>119</c><c><spanx style="verb">STATUS_RESET_UNKNOWN</spanx></c><c>Failure while recovering cause of reset.</c>
<c>120</c><c><spanx style="verb">STATUS_RESET_WATCHDOG</spanx></c><c>Software failed to make sufficient progress.</c>
</texttable>
</section>

<section anchor="capabilities" title="Capabilities">
<t>Capabilities are how an NCP can advertise support for specific behaviors and functionalities. They can be fetched via the <spanx style="verb">PROP_CAPS</spanx> property.
</t>
<t>See <xref target="prop-caps"/> for more information on <spanx style="verb">PROP_CAPS</spanx>.
</t>
<t>A registry of capability codes is maintained by IANA with various reservation policies in effect for different ranges of values as shown in the table below:
</t>
<texttable>
<ttcol align="left">Capability Range</ttcol>
<ttcol align="left">Description</ttcol>

<c>0 - 1027</c><c>Standards Action</c>
<c>1027 - 15,359</c><c>Unassigned</c>
<c>15,360 - 16,383</c><c>Private Use</c>
<c>16,384 - 1,999,999</c><c>Unassigned</c>
<c>2,000,000 - 2,097,151</c><c>Experimental Use</c>
</texttable>
<t>The initial content of the registry is shown in the table below.
</t>
<texttable>
<ttcol align="left">Code</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Description</ttcol>

<c>1</c><c><spanx style="verb">CAP_LOCK</spanx></c><c>See <xref target="prop-lock"/></c>
<c>2</c><c><spanx style="verb">CAP_NET_SAVE</spanx></c><c>draft-rquattle-spinel-network-save</c>
<c>3</c><c><spanx style="verb">CAP_HBO</spanx></c><c>draft-rquattle-spinel-hbo</c>
<c>4</c><c><spanx style="verb">CAP_POWER_SAVE</spanx></c><c>EDITOR: to be provided.</c>
<c>5</c><c><spanx style="verb">CAP_COUNTERS</spanx></c><c>EDITOR: to be provided.</c>
<c>7</c><c><spanx style="verb">CAP_PEEK_POKE</spanx></c><c>Peek/poke debugging commands.</c>
<c>8</c><c><spanx style="verb">CAP_WRITABLE_RAW_STREAM</spanx></c><c><spanx style="verb">PROP_STREAM_RAW</spanx> is writable.</c>
<c>9</c><c><spanx style="verb">CAP_GPIO</spanx></c><c>draft-rquattle-spinel-gpio</c>
<c>10</c><c><spanx style="verb">CAP_TRNG</spanx></c><c>draft-rquattle-spinel-trng</c>
<c>11</c><c><spanx style="verb">CAP_CMD_MULTI</spanx></c><c>See <xref target="cmd-prop-value-multi-get"/>, <xref target="cmd-prop-value-multi-set"/>, <xref target="cmd-prop-values-are"/></c>
<c>12</c><c><spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx></c><c>See <xref target="prop-unsol-update-filter"/>, <xref target="prop-unsol-update-list"/></c>
<c>48</c><c><spanx style="verb">CAP_ROLE_ROUTER</spanx></c><c>EDITOR: to be provided.</c>
<c>49</c><c><spanx style="verb">CAP_ROLE_SLEEPY</spanx></c><c>EDITOR: to be provided.</c>
<c>512</c><c><spanx style="verb">CAP_MAC_WHITELIST</spanx></c><c>EDITOR: to be provided.</c>
<c>513</c><c><spanx style="verb">CAP_MAC_RAW</spanx></c><c>EDITOR: to be provided.</c>
<c>514</c><c><spanx style="verb">CAP_OOB_STEERING_DATA</spanx></c><c>EDITOR: to be provided.</c>
</texttable>
</section>

<section anchor="properties" title="Properties">
<t>This section defines the syntax and specific operational details
of the Spinel properties common to the core protocol.
</t>

<section anchor="command-semantics" title="Command Semantics">
<t>Individual properties MAY support one or more of the following
commands:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VALUE_GET</spanx> (<xref target="cmd-prop-value-get"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_SET</spanx> (<xref target="cmd-prop-value-set"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_INSERT</spanx> (<xref target="cmd-prop-value-insert"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_REMOVE</spanx> (<xref target="cmd-prop-value-remove"/>)</t>
</list>
</t>
<t>Upon an error condition, the NCP SHALL respond in the typical
fasion of indicating the error code via a <spanx style="verb">CMD_PROP_VALUE_IS</spanx> command
with the appropriate status code(See @detail-status).
</t>
<t>Unless otherwise specified, an NCP MUST NOT emit a
<spanx style="verb">PROP_LAST_STATUS</spanx> of <spanx style="verb">STATUS_OK</spanx> in response to the successful
execution of any of the above commands.
</t>
<t>Upon successful execution of one of the property manipulation commands, the
NCP SHALL send one of the following commands (with the same property key that
was used for the sending command) to indicate success:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VALUE_IS</spanx> (<xref target="cmd-prop-value-is"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_INSERTED</spanx> (<xref target="cmd-prop-value-inserted"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_REMOVED</spanx> (<xref target="cmd-prop-value-removed"/>)</t>
</list>
</t>
<t>When an NCP has successfully handled a <spanx style="verb">CMD_PROP_VALUE_INSERT</spanx> or
<spanx style="verb">CMD_PROP_VALUE_REMOVE</spanx> command on a multi-value property, the NCP
SHOULD respond with a <spanx style="verb">CMD_PROP_VALUE_INSERTED</spanx> or
<spanx style="verb">CMD_PROP_VALUE_REMOVED</spanx>, respectfully. However, if doing so is
prohibitively complex, the NCP MAY instead respond with a
<spanx style="verb">CMD_PROP_VALUE_IS</spanx> containing the entire list of items.
</t>
<t>The reason for the above behavior is that the NCP is the ultimate
authority on the value of all properties. By always indicating success
by responding with the value of the property, we can make sure that
the software running on the host is in sync with the behavior of the NCP.
</t>
</section>

<section anchor="asynchronous-updates" title="Asynchronous Updates">
<t>Some properties support indicating changes in their state asynchronously
by sending the following commands with a TID value of 0:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VALUE_IS</spanx> (<xref target="cmd-prop-value-is"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_INSERTED</spanx> (<xref target="cmd-prop-value-inserted"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_REMOVED</spanx> (<xref target="cmd-prop-value-removed"/>)</t>
</list>
</t>
<t>Asynchronous updates for specific properties can be enabled or disabled
using <spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx>, documented in <xref target="prop-unsol-update-filter"/>.
</t>
</section>

<section anchor="property-identifiers" title="Property Identifiers">
<t>IANA maintains a registry of Spinel <spanx style="verb">PROP_ID</spanx> property identifier
numbers, with varying registration policies assigned for different
ranges according to the following table:
</t>
<texttable>
<ttcol align="left">Property ID Range</ttcol>
<ttcol align="left">Description</ttcol>

<c>0 - 127</c><c>Standards Action</c>
<c>128 - 4,095</c><c>Unassigned</c>
<c>4,096 - 6,143</c><c>Standards Action</c>
<c>6,144 - 15,359</c><c>Unassigned</c>
<c>15,360 - 16,383</c><c>Private Use</c>
<c>16,384 - 17,407</c><c>Standards Action</c>
<c>17,408 - 1,999,999</c><c>Unassigned</c>
<c>2,000,000 - 2,097,151</c><c>Experimental Use</c>
</texttable>
</section>

<section anchor="property-identifier-sections" title="Property Identifier Sections">
<t>Standard property identifier numbers are assigned in a hierarchy
according to their purpose, as shown in the table below:
</t>
<texttable>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Primary</ttcol>
<ttcol align="left">Extended</ttcol>
<ttcol align="left">Documentation</ttcol>

<c>Core</c><c>0 - 31</c><c>4,096 - 4,607</c><c><xref target="prop-core"/></c>
<c>PHY</c><c>32 - 47</c><c>4,608 - 4,863</c><c>Physical (PHY) layer specific</c>
<c>MAC</c><c>48 - 63</c><c>4,864 - 5,119</c><c>Media access (MAC) layer specific</c>
<c>NET</c><c>64 - 79</c><c>5,120 - 5,375</c><c><xref target="prop-net"/></c>
<c>Tech</c><c>80 - 95</c><c>5,376 - 5,631</c><c><xref target="prop-interface-type"/></c>
<c>IPv6</c><c>96 - 111</c><c>5,632 - 5,887</c><c><xref target="prop-ipv6"/></c>
<c>Stream</c><c>112 - 127</c><c>5,888 - 6,143</c><c><xref target="prop-core"/></c>
<c>Debug</c><c>no primary</c><c>16,384 - 17,407</c><c><xref target="prop-debug"/></c>
</texttable>
<t>Note: most of the property identifier sections have two reserved
ranges: a &quot;primary&quot; range (which is encoded as a single octet) and an
&quot;extended&quot; range (which is encoded as two octets). Properties used
very frequently are generally allocated from the &quot;primary&quot; range.
</t>
<t>EDITOR: the IANA registration template for Spinel standard properties identifiers requires the &quot;Section Name&quot; and &quot;Range Identifier&quot; parameters to facilitate the assignment of a suitable number from the appropriate range.
</t>
</section>

<section anchor="prop-core" title="Core Properties">

<section anchor="prop-last-status" title="PROP 0: PROP_LAST_STATUS">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Only</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: Reset Reason Code</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Format:</c><c>PUI</c>
<c>Fields:</c><c><spanx style="verb">STATUS_CODE</spanx></c>
</texttable>
<t>This property describes the status code of the last NCP operation. For
many commands, failure is indicated by emitting this property with the
TID matching the failing command. It is generally not necessary to
ever fetch the value of this property explicitly, as it is often
emitted directly as an error response. It is also occasionally emitted
as a success response with a value of <spanx style="verb">STATUS_OK</spanx>.
</t>
<t>Upon NCP reset, this property MUST be emitted with a status code
indicating the reset reason.
</t>
<t>Upon receiving an update to PROP<spanx style="emph">LAST</spanx>STATUS with a status code that
indicates a reset, the host SHALL assume that the NCP has been reset
and that all properties have reverted to their defined after-reset
values.
</t>
<t>See <xref target="status-codes"/> for the complete list of status codes.
</t>
</section>

<section anchor="prop-protocol-version" title="PROP 1: PROP_PROTOCOL_VERSION">
<t>
<list style="symbols">
<t>Type: Single-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: 4, 3</t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Format:</c><c>PUI</c><c>PUI</c>
<c>Fields:</c><c><spanx style="verb">MAJOR_VERSION</spanx></c><c><spanx style="verb">MINOR_VERSION</spanx></c>
</texttable>
<t>Describes the spinel protocol version information. This property
contains four fields, each encoded as a packed unsigned integer:
</t>
<t>
<list style="hanging">
<t hangText="MAJOR_VERSION">
<vspace />
The major version number is used to identify backward incompatible
differences between protocol versions. The OS MUST enter a
FAULT(TODO: Define this) state if the given major version number is
unsupportable.</t>
<t hangText="MINOR_VERSION">
<vspace />
The minor version number is used to identify backward-compatible
differences between protocol versions. A mismatch between the
advertised minor version number and the minor version that is
supported by the OS SHOULD NOT be fatal to the operation of the
OS.</t>
</list>
</t>
<t>This document describes major version 4, minor version 3 of this
protocol. (TODO: UPDATE THIS)
</t>
<t>If a NCP supports multiple NLIs, the value of this property MUST
be identical across all implemented NLIs.
</t>
</section>

<section anchor="prop-ncp-version" title="PROP 2: PROP_NCP_VERSION">
<t>
<list style="symbols">
<t>Type: Single-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Scope: Firmware</t>
<t>Post-Reset Value: Implementation-Specific</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>ASCII</c><c>CONST</c>
<c>Fields:</c><c><spanx style="verb">NCP_VERSION</spanx></c><c>0x00</c>
</texttable>
<t>Contains a zero-terminated ASCII string which describes the firmware
currently running on the NCP.
</t>
<t>The value of this string MUST be different for every firmware
release.
</t>
<t>The format of the string is not strictly defined, but it is intended
to present similarly to the &quot;User-Agent&quot; string from HTTP. The
following format is RECOMMENDED:
</t>
<t><spanx style="verb">STACK-NAME/STACK-VERSION[BUILD-INFO][; OTHER-INFO][; BUILD-DATE]</spanx>
</t>
<t>Where:
</t>
<t>
<list style="hanging">
<t hangText="STACK-NAME">
<vspace />
The name of the software running on the NCP.</t>
<t hangText="STACK-VERSION">
<vspace />
The version number of the software running on the NCP, like <spanx style="verb">1.0</spanx> or
<spanx style="verb">3.2.6</spanx></t>
<t hangText="BUILD-INFO">
<vspace />
Optional information indicating a specific build, like <spanx style="verb">b125</spanx> or
<spanx style="verb">d26-25-gb684c7f</spanx>.</t>
<t hangText="OTHER-INFO">
<vspace />
Other optional information about the build.</t>
<t hangText="BUILD-DATE">
<vspace />
OPTIONAL build date.</t>
</list>
</t>
<t>Examples:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">OpenThread/1.0d26-25-gb684c7f; DEBUG; May 9 2016 18:22:04</spanx></t>
<t><spanx style="verb">ConnectIP/2.0b125 s1 ALPHA; Sept 24 2015 20:49:19</spanx></t>
</list>
</t>
<t>If a NCP supports multiple NLIs, the value of this property MUST be
identical across all implemented NLIs.
</t>
</section>

<section anchor="prop-interface-type" title="PROP 3: PROP_INTERFACE_TYPE">
<t>
<list style="symbols">
<t>Type: Single-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: Implementation-Specific</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Format:</c><c>PUI</c>
<c>Fields:</c><c><spanx style="verb">INTERFACE_TYPE</spanx></c>
</texttable>
<t>This unsigned packed integer identifies the network protocol
implemented by this NCP. A registry of network interface type codes is
maintained by IANA with a reservation policy of Specification
Required. The initial content of the registry is shown in the table
below:
</t>
<texttable>
<ttcol align="left">Code</ttcol>
<ttcol align="left">Network protocol</ttcol>

<c>0</c><c>Bootloader</c>
<c>2</c><c>ZigBee IP(TM)</c>
<c>3</c><c>Thread(R)</c>
</texttable>
<t>The OS MUST enter a FAULT state if it does not recognize the
network protocol given by the NCP.
</t>
</section>

<section anchor="prop-interface-vendor-id" title="PROP 4: PROP_INTERFACE_VENDOR_ID">
<t>
<list style="symbols">
<t>Type: Single-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: Implementation-Specific</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Format:</c><c>PUI</c>
<c>Fields:</c><c><spanx style="verb">VENDOR_ID</spanx></c>
</texttable>
<t><cref source="JW">I have no idea how to write the IANA registry creation text for this. --</cref></t>
<t><cref source="RQ">Maybe we should switch this over to be a string instead? --</cref></t>
</section>

<section anchor="prop-caps" title="PROP 5: PROP_CAPS">
<t>
<list style="symbols">
<t>Type: Multiple-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: Implementation-Specific</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">...</ttcol>

<c>Format:</c><c>PUI</c><c>PUI</c><c>...</c>
<c>Fields:</c><c><spanx style="verb">CAP</spanx></c><c><spanx style="verb">CAP</spanx></c><c>...</c>
</texttable>
<t>Describes the supported capabilities of this NCP. Encoded as a list of
packed unsigned integers. See <xref target="capabilities"/> for a list of values.
</t>
</section>

<section anchor="prop-interface-count" title="PROP 6: PROP_INTERFACE_COUNT">
<t>
<list style="symbols">
<t>Type: Single-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: 1-4</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>INT</c>
<c>Fields:</c><c><spanx style="verb">INTERFACE_COUNT</spanx></c>
</texttable>
<t>Describes the number of concurrent interfaces supported by this NCP.
Since the concurrent interface mechanism is still TBD, this value
MUST always be one.
</t>
<t>If a NCP supports multiple NLIs, the value of this property MUST be
identical across all implemented NLIs.
</t>
</section>

<section anchor="prop-power-state" title="PROP 7: PROP_POWER_STATE">
<t>
<list style="symbols">
<t>Type: Single-Value, Read/Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required:
<list style="symbols">
<t>Read: Yes</t>
<t>Write: <spanx style="strong">RECOMENDED</spanx></t>
</list></t>
<t>Post-Reset Value: <spanx style="verb">POWER_STATE_ONLINE</spanx></t>
<t>Related Capabilities:
<list style="symbols">
<t><spanx style="verb">CAP_POWER_STATE</spanx>: Required when writable</t>
</list></t>
<t>See Also: <xref target="prop-mac-data-poll-period"/></t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>INT</c>
<c>Fields:</c><c><spanx style="verb">POWER_STATE</spanx></c>
</texttable>
<t>A single octet coded that indicates the current power state of the
NCP. Setting this property allows controls of the current NCP power
state. The following table enumerates the standard codes and their
significance.
</t>
<texttable>
<ttcol align="left">Code</ttcol>
<ttcol align="left">Name</ttcol>

<c>0</c><c><spanx style="verb">POWER_STATE_OFFLINE</spanx></c>
<c>1</c><c><spanx style="verb">POWER_STATE_DEEP_SLEEP</spanx></c>
<c>2</c><c><spanx style="verb">POWER_STATE_STANDBY</spanx></c>
<c>3</c><c><spanx style="verb">POWER_STATE_LOW_POWER</spanx></c>
<c>4</c><c><spanx style="verb">POWER_STATE_ONLINE</spanx></c>
</texttable>
<t><cref source="JW">TODO: We should consider reversing the numbering here so
     that 0 is `POWER_STATE_ONLINE`. We may also want to include
     some extra values between the defined values for future
     expansion, so that we can preserve the ordered relationship.
  --</cref></t>
<t>
<list style="hanging">
<t hangText="POWER_STATE_OFFLINE">
<vspace />
NCP is physically powered off.</t>
<t hangText="POWER_STATE_DEEP_SLEEP">
<vspace />
NCP is not powered to detect any events on physical network media.</t>
<t hangText="POWER_STATE_STANDBY">
<vspace />
NCP is powered only to detect certain events on physical network media that signal to wake.</t>
<t hangText="POWER_STATE_LOW_POWER">
<vspace />
NCP is powered only for limited responsiveness for power conservation purposes.</t>
<t hangText="POWER_STATE_ONLINE">
<vspace />
NCP is powered for full responsiveness.</t>
</list>
</t>
</section>

<section anchor="prop-hwaddr" title="PROP 8: PROP_HWADDR">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Only</t>
<t>Asynchronous Updates: No</t>
<t>Post-Reset Value: Determined by Factory</t>
<t>Required: REQUIRED</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">8</ttcol>

<c>Format:</c><c>EUI-64-BE</c>
<c>Fields:</c><c><spanx style="verb">HWADDR</spanx></c>
</texttable>
<t>The EUI-64 (TODO:CITE) format of the link-layer address of the device.
MAY be different across multiple NLIs.
</t>
</section>

<section anchor="prop-lock" title="PROP 9: PROP_LOCK">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: 0</t>
<t>Required Capability: <spanx style="verb">CAP_LOCK</spanx></t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>Boolean</c>
<c>Fields:</c><c><spanx style="verb">LOCK</spanx></c>
</texttable>
<t>Property transaction lock. Used for grouping transactional changes to
several properties for simultaneous commit, or to temporarily prevent
the automatic updating of property values. When this property is set,
all non-Spinel-related operations of the NCP are effectively frozen
until it is cleared. There is no support for transaction rollback.
</t>
<t>This property is only supported if the <spanx style="verb">CAP_LOCK</spanx> capability is
present.
</t>
<t>Unlike most other properties, setting this property to true when the
value of the property is already true SHALL fail with a last status
of <spanx style="verb">STATUS_ALREADY</spanx>.
</t>
</section>

<section anchor="prop-host-power-state" title="PROP 10: PROP_HOST_POWER_STATE">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: <spanx style="verb">HOST_POWER_STATE_ONLINE</spanx></t>
<t>Required Capability: <spanx style="verb">???</spanx> (TODO: Assign a capability)</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>INT</c>
<c>Fields:</c><c><spanx style="verb">HOST_POWER_STATE</spanx></c>
</texttable>
<t>Describes the current power state of the <spanx style="emph">OS</spanx>. This property is used
by the OS to inform the NCP when it has changed power states. The NCP
can then use this state to determine which properties need
asynchronous updates. Enumeration is encoded as a single unsigned
octet.
</t>
<t>The following table enumerates the standard codes and their significance.
</t>
<texttable>
<ttcol align="left">Code</ttcol>
<ttcol align="left">Name</ttcol>

<c>0</c><c><spanx style="verb">HOST_POWER_STATE_OFFLINE</spanx></c>
<c>1</c><c><spanx style="verb">HOST_POWER_STATE_DEEP_SLEEP</spanx></c>
<c>3</c><c><spanx style="verb">HOST_POWER_STATE_LOW_POWER</spanx></c>
<c>4</c><c><spanx style="verb">HOST_POWER_STATE_ONLINE</spanx></c>
</texttable>
<t><cref source="JW">EDITOR: We should consider reversing the numbering here so that 0
     is `POWER_STATE_ONLINE`. We may also want to include some additional
     reserved values between the defined values for future expansion, so
     that we can preserve the ordered relationship. See the similar
     editorial comment at (#prop-power-state).
  --</cref></t>
<t>
<list style="hanging">
<t hangText="HOST_POWER_STATE_OFFLINE">
<vspace />
OS is physically powered off and cannot be awakened by the NCP.</t>
<t hangText="HOST_POWER_STATE_DEEP_SLEEP">
<vspace />
OS is in a deep low power state and will require a long time to
wake. In this state, the NCP MUST NOT send any commands, including
any commands that contain network packets, prior to signaling the host
explicitly to awaken and receiving a signal to update the state to
<spanx style="verb">HOST_POWER_STATE_ONLINE</spanx>.</t>
<t hangText="HOST_POWER_STATE_LOW_POWER">
<vspace />
OS is in a low power state and can be awakened quickly.</t>
<t hangText="HOST_POWER_STATE_ONLINE">
<vspace />
OS is powered for full responsiveness.</t>
</list>
</t>
<t>After the OS sends <spanx style="verb">CMD_PROP_VALUE_SET</spanx> for this property with a value
other than <spanx style="verb">HOST_POWER_STATE_ONLINE</spanx>, it SHOULD wait for the NCP
to acknowledge the property update (with a <spanx style="verb">CMD_VALUE_IS</spanx> command)
before entering the specified power state.
</t>
<t>Upon the NCP receiving any command when the state is not
<spanx style="verb">HOST_POWER_STATE_ONLINE</spanx>, it MUST silently update the state to
the <spanx style="verb">HOST_POWER_STATE_ONLINE</spanx> value.
</t>
<t>When the state is not <spanx style="verb">HOST_POWER_STATE_ONLINE</spanx>, the NCP <spanx style="strong">SHOULD
NOT</spanx> send any commands except important notifications that warrant
awakening the OS host, and the NCP MUST NOT send any informative
messages on <spanx style="verb">PROP_DEBUG_STREAM</spanx>.
</t>
<t>The OS MUST NOT send a value of <spanx style="verb">HOST_POWER_STATE</spanx> other than one
of the standard codes defined here. If the NCP receives a value other
than a standard code, then it SHOULD set the state to
<spanx style="verb">HOST_POWER_STATE_LOW_POWER</spanx>.
</t>
<t>If the NCP has the <spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx> capability, any
unsolicited property updates masked by <spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx>
should be honored while the OS indicates it is in a low-power state.
After resuming to the <spanx style="verb">HOST_POWER_STATE_ONLINE</spanx> state, the value of
<spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx> MUST be unchanged from the value
assigned prior to the OS indicating it was entering a low-power state.
</t>
<t>The OS MUST use NLI 0 with commands using this property. The NCP
SHOULD explicitly fail to process commands setting this property
if NLI is not zero. The operational semantics of this property when
NLI is not zero are not specified.
</t>
</section>

<section anchor="prop-unsol-update-filter" title="PROP 4104: PROP_UNSOL_UPDATE_FILTER">
<t>
<list style="symbols">
<t>Type: Multi-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: Empty</t>
<t>Scope: NCP</t>
<t>Required Capability: <spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx></t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">...</ttcol>

<c>Format:</c><c>PUI</c><c>PUI</c><c>...</c>
<c>Fields:</c><c><spanx style="verb">PROP_ID</spanx></c><c><spanx style="verb">PROP_ID</spanx></c><c>...</c>
</texttable>
<t>Contains a list of property IDs which are <spanx style="emph">excluded</spanx> from generating
unsolicited value updates. This property MUST be empty after NCP
reset.
</t>
<t>In other words, the OS may opt-out of unsolicited property updates for
a specific property by adding that property id to this list.
</t>
<t>The OS SHOULD NOT add properties to this list which are not
present in <spanx style="verb">PROP_UNSOL_UPDATE_LIST</spanx>. If such properties are added, the
NCP MUST ignore the unsupported properties.
</t>
<t><cref source="RQ">The justification for the above behavior is to attempt to avoid possible
     future interop problems by explicitly making sure that unknown
     properties are ignored. Since unknown properties will obviously not be
     generating unsolicited updates, it seems fairly harmless. An
     implementation may print out a warning to the debug stream.

     Note that the error is still detectable: If you VALUE\_SET unsupported
     properties, the resulting VALUE\_IS would contain only the supported
     properties of that set(since the unsupported properties would be
     ignored). If an implementation cares that much about getting this
     right then it needs to make sure that it checks
     PROP\_UNSOL\_UPDATE\_LIST first.
  --</cref></t>
</section>

<section anchor="prop-unsol-update-list" title="PROP 4105: PROP_UNSOL_UPDATE_LIST">
<t>
<list style="symbols">
<t>Type: Multi-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: Implementation Specific</t>
<t>Scope: Firmware</t>
<t>Required Capability: <spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx></t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">...</ttcol>

<c>Format:</c><c>PUI</c><c>PUI</c><c>...</c>
<c>Fields:</c><c><spanx style="verb">PROP_ID</spanx></c><c><spanx style="verb">PROP_ID</spanx></c><c>...</c>
</texttable>
<t>Contains a list of properties which are capable of generating
unsolicited value updates. This list can be used when populating
<spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx> to disable all unsolicited property
updates.
</t>
<t>The NCP MUST NOT change the value of this property after sending a
<spanx style="verb">CMD_VALUE_IS</spanx> for <spanx style="verb">PROP_LAST_STATUS</spanx> with any of the
<spanx style="verb">STATUS_RESET_xxxxx</spanx> status codes.
</t>
<t>Note: not all properties that support unsolicited updates need to be
listed here. Some properties, network media scan results for example,
are only generated due to direct action on the part of the OS, so
those properties SHOULD NOT not be included in this list.
</t>
</section>
</section>

<section anchor="prop-stream" title="Stream Properties">

<section anchor="prop-stream-debug" title="PROP 112: PROP_STREAM_DEBUG">
<t>
<list style="symbols">
<t>Type: Character-Stream, Output-Only</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: OPTIONAL</t>
<t>Scope: NLI</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">n</ttcol>

<c>Format:</c><c>UTF8</c>
<c>Fields:</c><c><spanx style="verb">DEBUG_DATA</spanx></c>
</texttable>
<t>This stream provides human-readable debugging output which may be
displayed in the OS logs. It is intended to be treated as a one-way
virtual serial stream. The OS MUST NOT assume that each emission
of this property is self-contained, instead the OS must use newline
characters for that purpose.
</t>
<t>The location of newline characters MUST NOT not assumed by the
OS: it is the NCP's responsibility to insert newline characters
where needed, just like with any other text stream.
</t>
<t>The emitted data is UTF8-encoded without any zero termination. Note
that the last UTF8 character MAY possibly be truncated. If the
last UTF8 character is truncated, the truncated bytes MUST be the
first bytes of the next emission from this stream.
</t>
</section>

<section anchor="prop-stream-raw" title="PROP 113: PROP_STREAM_RAW">
<t>
<list style="symbols">
<t>Type: Packet-Stream, Input/Output</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: OPTIONAL</t>
<t>Scope: NLI</t>
<t>Related Capabilities:
<list style="symbols">
<t><spanx style="verb">CAP_WRITABLE_RAW_STREAM</spanx>: Can be written to if present.</t>
</list></t>
</list>
</t>
<texttable>
<ttcol align="left">Bytes:</ttcol>
<ttcol align="left">2</ttcol>
<ttcol align="left">n</ttcol>
<ttcol align="left">n</ttcol>

<c>Format:</c><c>UINT16-LE</c><c>DATA</c><c>OPTIONAL DATA</c>
<c>Fields:</c><c>FRAME_DATA_LEN</c><c>FRAME_DATA</c><c>FRAME_METADATA</c>
</texttable>
<t>This stream provides the capability of sending and receiving raw
packets to and from the network. The exact format of the frame
metadata and data is dependent on the MAC and PHY being used.
</t>
<t>Implementations MAY support the ability to transmit arbitrary raw
packets. Support for this feature is indicated by the presence of the
<spanx style="verb">CAP_WRITABLE_RAW_STREAM</spanx> capability.
</t>
<t>If the capability <spanx style="verb">CAP_WRITABLE_RAW_STREAM</spanx> is set, then packets
written to this stream with <spanx style="verb">CMD_PROP_VALUE_SET</spanx> will be sent out over
the radio. This allows the caller to use the network directly, with
the full network layer stack being implemented on the OS instead of
the NCP.
</t>

<section anchor="frame-metadata-format" title="Frame Metadata Format">
<t>Any data past the end of <spanx style="verb">FRAME_DATA_LEN</spanx> is considered metadata and
is OPTIONAL. Frame metadata MAY be empty or partially
specified. The operational semantics of using frame metadata is not
specified in the core protocol.
</t>
</section>
</section>

<section anchor="prop-stream-net" title="PROP 114: PROP_STREAM_NET">
<t>
<list style="symbols">
<t>Type: Packet-Stream, Input/Output</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED</t>
<t>Scope: NLI</t>
</list>
</t>
<texttable>
<ttcol align="left">Bytes:</ttcol>
<ttcol align="left">2</ttcol>
<ttcol align="left">n</ttcol>
<ttcol align="left">n</ttcol>

<c>Format:</c><c>UINT16-LE</c><c>IPv6</c><c>OPTIONAL DATA</c>
<c>Fields:</c><c>FRAME_DATA_LEN</c><c>FRAME_DATA</c><c>FRAME_METADATA</c>
</texttable>
<t>This stream provides the capability of sending and receiving data
packets to and from the currently attached network.
</t>
<t>Any data past the end of <spanx style="verb">FRAME_DATA_LEN</spanx> is considered metadata, the
format of which is described in <xref target="frame-metadata-format"/>.
</t>
</section>

<section anchor="prop-stream-net-insecure" title="PROP 115: PROP_STREAM_NET_INSECURE">
<t>
<list style="symbols">
<t>Type: Packet-Stream, Input/Output</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED</t>
<t>Scope: NLI</t>
</list>
</t>
<texttable>
<ttcol align="left">Bytes:</ttcol>
<ttcol align="left">2</ttcol>
<ttcol align="left">n</ttcol>
<ttcol align="left">n</ttcol>

<c>Format:</c><c>UINT16-LE</c><c>IPv6</c><c>OPTIONAL DATA</c>
<c>Fields:</c><c>FRAME_DATA_LEN</c><c>FRAME_DATA</c><c>FRAME_METADATA</c>
</texttable>
<t>This stream provides the capability of sending and receiving plaintext
non-authenticated data packets to and from the currently attached
network.
</t>
<t>Any data past the end of <spanx style="verb">FRAME_DATA_LEN</spanx> is considered metadata, the
format of which is described in <xref target="frame-metadata-format"/>.
</t>
</section>
</section>

<section anchor="prop-phy" title="PHY Properties">

<section anchor="prop-phy-enabled" title="PROP 32: PROP_PHY_ENABLED">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required:
<list style="symbols">
<t>Read: Yes</t>
<t>Write: No</t>
</list></t>
<t>Post-Reset Value: 0 (false)</t>
<t>Related Capabilities: SPINEL_CAP_MAC_RAW</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c><spanx style="verb">PHY_ENABLED</spanx></c>
</texttable>
<t>Set to 1 if the PHY is enabled, set to 0 otherwise.
May be directly enabled to bypass higher-level packet processing
in order to implement things like packet sniffers. This property
can only be written if the <spanx style="verb">SPINEL_CAP_MAC_RAW</spanx> capability is present.
</t>
</section>

<section anchor="prop-phy-chan" title="PROP 33: PROP_PHY_CHAN">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Unit: Channel Index</t>
<t>Post-Reset Value: Unspecified</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UINT8</c>
<c>Fields:</c><c><spanx style="verb">CHANNEL</spanx></c>
</texttable>
<t>Value is the current channel. Must be set to one of the
values contained in <spanx style="verb">PROP_PHY_CHAN_SUPPORTED</spanx>.
</t>
</section>

<section anchor="prop-phy-chan-supported" title="PROP 34: PROP_PHY_CHAN_SUPPORTED">
<t>
<list style="symbols">
<t>Type: Multiple-Value, Constant</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Unit: Channel Index</t>
<t>Post-Reset Value: Implementation Specific</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">...</ttcol>

<c>Format:</c><c>UINT8</c><c>UINT8</c><c>...</c>
<c>Fields:</c><c><spanx style="verb">CHANNEL</spanx></c><c><spanx style="verb">CHANNEL</spanx></c><c>...</c>
</texttable>
<t>Value is a list of channel values that are supported by the
NCP.
</t>
</section>

<section anchor="prop-phy-freq" title="PROP 35: PROP_PHY_FREQ">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Only</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Unit: kHz</t>
<t>Post-Reset Value: Unspecified</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UINT32_LE</c>
<c>Fields:</c><c><spanx style="verb">FREQ</spanx></c>
</texttable>
<t>Value is the radio frequency (in kilohertz) of the
current channel.
</t>
</section>

<section anchor="prop-phy-cca-threshold" title="PROP 36: PROP_PHY_CCA_THRESHOLD">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Unit: dB</t>
<t>Post-Reset Value: Implementation-specific default</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>INT8</c>
<c>Fields:</c><c><spanx style="verb">CCA_THRESHOLD</spanx></c>
</texttable>
<t>Value is the CCA (clear-channel assessment) threshold. Set to
-128 to disable.
</t>
<t>The specific meaning of zero dB is implementation-specific,
but MUST be consistant with definitions of other properties
that express power. It is RECOMMENDED that zero dB
represent one milliwatt of power (0dBm), as measured from the
antenna connector.
</t>
<t>When setting, the value SHOULD be rounded down to a value
that is supported by the underlying radio hardware.
</t>
</section>

<section anchor="prop-phy-tx-power" title="PROP 37: PROP_PHY_TX_POWER">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Unit: dB</t>
<t>Post-Reset Value: 0dB</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>INT8</c>
<c>Fields:</c><c><spanx style="verb">TX_POWER</spanx></c>
</texttable>
<t>Value is the transmit power of the radio, measured in decibells.
</t>
<t>The specific meaning of zero dB is implementation-specific,
but MUST be consistant with definitions of other properties
that express power. It is RECOMMENDED that zero dB
represent one milliwatt of power (0dBm), as measured from the
antenna connector.
</t>
<t>When setting, the value SHOULD be rounded down to a value
that is supported by the underlying radio hardware.
</t>
</section>

<section anchor="prop-phy-rssi" title="PROP 38: PROP_PHY_RSSI">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Only</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Unit: dB</t>
<t>Post-Reset Value: Unspecified</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>INT8</c>
<c>Fields:</c><c><spanx style="verb">RSSI</spanx></c>
</texttable>
<t>Value is the current RSSI (Received Signal Strength Indication)
from the radio. This value can be used in energy scans and for
determining the ambient noise floor for the operating environment.
</t>
<t>The specific meaning of zero dB is implementation-specific,
but MUST be consistant with definitions of other properties
that express power. It is RECOMMENDED that zero dB
represent one milliwatt of power (0dBm), as measured from the
antenna connector.
</t>
</section>

<section anchor="prop-phy-rx-sensitivity" title="PROP 39: PROP_PHY_RX_SENSITIVITY">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Only</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Unit: dB</t>
<t>Post-Reset Value: Unspecified</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>INT8</c>
<c>Fields:</c><c><spanx style="verb">RX_SENSITIVITY</spanx></c>
</texttable>
<t>Value is the radio receive sensitivity. This value can be used as
lower bound noise floor for link metrics computation.
</t>
<t>The specific meaning of zero dB is implementation-specific,
but MUST be consistant with definitions of other properties
that express power. It is RECOMMENDED that zero dB
represent one milliwatt of power (0dBm), as measured from the
antenna connector.
</t>
</section>
</section>

<section anchor="prop-mac" title="MAC Properties">

<section anchor="prop-mac-scan-state" title="PROP 48: PROP_MAC_SCAN_STATE">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED</t>
<t>Unit: Enumeration</t>
<t>Post-Reset Value: 0 (false)</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UINT8</c>
<c>Fields:</c><c><spanx style="verb">SCAN_STATE</spanx></c>
</texttable>
<t>TODO(RQ): This needs to be re-thought out. I don't like the whole discovery
thing being a separate scan state. Maybe we should add another property
for scanning only compatible networks.
</t>
<t>Possible Values:
</t>
<t>
<list style="symbols">
<t>0: <spanx style="verb">SCAN_STATE_IDLE</spanx></t>
<t>1: <spanx style="verb">SCAN_STATE_BEACON</spanx></t>
<t>2: <spanx style="verb">SCAN_STATE_ENERGY</spanx></t>
<t>3: <spanx style="verb">SCAN_STATE_DISCOVER</spanx> DEPRECATED</t>
</list>
</t>
<t>Set to <spanx style="verb">SCAN_STATE_BEACON</spanx> to start an active scan.
Beacons will be emitted from <spanx style="verb">PROP_MAC_SCAN_BEACON</spanx>.
</t>
<t>Set to <spanx style="verb">SCAN_STATE_ENERGY</spanx> to start an energy scan.
Channel energy result will be reported by emissions
of <spanx style="verb">PROP_MAC_ENERGY_SCAN_RESULT</spanx> (per channel).
</t>
<t>DEPRECATED: Set to <spanx style="verb">SCAN_STATE_DISOVER</spanx> to start a Thread MLE discovery
scan operation. Discovery scan result will be emitted from
<spanx style="verb">PROP_MAC_SCAN_BEACON</spanx>.
</t>
<t>Value switches to <spanx style="verb">SCAN_STATE_IDLE</spanx> when scan is complete.
</t>
</section>

<section anchor="prop-mac-scan-mask" title="PROP 49: PROP_MAC_SCAN_MASK">
<t>
<list style="symbols">
<t>Type: Multi-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED</t>
<t>Unit: Channel Index</t>
<t>Post-Reset Value: Same as PROP_PHY_CHAN_SUPPORTED</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">...</ttcol>

<c>Format:</c><c>UINT8</c><c>UINT8</c><c>...</c>
<c>Fields:</c><c><spanx style="verb">CHANNEL</spanx></c><c><spanx style="verb">CHANNEL</spanx></c><c>...</c>
</texttable>
<t>This property contains the list of channels that will be scanned.
</t>
</section>

<section anchor="prop-mac-scan-period" title="PROP 50: PROP_MAC_SCAN_PERIOD">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Unit: milliseconds per channel</t>
<t>Post-Reset Value: Implementation-specific-default</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UINT16_LE</c>
<c>Fields:</c><c><spanx style="verb">MSEC</spanx></c>
</texttable>
</section>

<section anchor="prop-mac-scan-beacon" title="PROP 51: PROP_MAC_SCAN_BEACON">
<t>
<list style="symbols">
<t>Type: Packet Stream, Output-Only</t>
<t>Required: REQUIRED</t>
<t>Packed-Encoding: <spanx style="verb">Ccdd</spanx> (or <spanx style="verb">Cct(ESSc)t(iCUdd)</spanx>)</t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>

<c>Format:</c><c>UINT8</c><c>INT8</c><c>UINT16_LE</c><c>DATA</c><c>UINT16_LE</c><c>DATA</c>
<c>Fields:</c><c>CH</c><c>RSSI</c><c>MAC_LEN</c><c>MAC_DATA</c><c>NET_LEN</c><c>NET_DATA</c>
</texttable>
<t>Scan beacons have two embedded structures which contain
information about the MAC layer and the NET layer. Their
format depends on the MAC and NET layer currently in use.
</t>
<t>For example, in an 802.15.4 PHY, MAC_DATA would be formatted as follows:
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">8</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>EUI-64</c><c>UINT16_LE</c><c>UINT16_LE</c><c>UINT8</c>
<c>Fields:</c><c>LONG_ADDR</c><c>SHORT_ADDR</c><c>PAN-ID</c><c>LQI</c>
</texttable>
<t>For the standard network layer, the NET_DATA formatted as follows:
</t>
<t>Bytes: | 1-3  |   1  |    <spanx style="emph">n</spanx>                             |  1   |  2 |  <spanx style="emph">n</spanx>    |  2| <spanx style="emph">n</spanx>
--------|----|------|----------------------------|------|---|------|----------
Format: | PUI | UINT8 | UTF8                      |  ZT  |  UINT16_LE  | DATA   |UINT16_LE   | DATA
Fields: | PROTO | FLAGS | NETWORK_NAME | 0x00 | XPANID_LEN| XPANID | STEERING_LEN | STEERING
</t>
<t>Extra parameters may be added to each of the structures
in the future, so care should be taken to read the length
that prepends each structure.
</t>
<t>The RSSI is measured in dB.
The specific meaning of zero dB is implementation-specific,
but MUST be consistant with definitions of other properties
that express power. It is RECOMMENDED that zero dB
represent one milliwatt of power (0dBm), as measured from the
antenna connector.
</t>
</section>

<section anchor="prop-mac-15-4-laddr" title="PROP 52: PROP_MAC_15_4_LADDR">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: <spanx style="strong">ONLY</spanx> used with 802.15.4 MAC</t>
<t>Post-Reset Value: Tehnology-dependent. MAY  be <spanx style="verb">PROP_HWADDR</spanx> or be randomly generated.</t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">8</ttcol>

<c>Format:</c><c>EUI-64</c>
<c>Fields:</c><c>LADDR</c>
</texttable>
<t>TODO(RQ): Break this out into an 802.15.4-specific section
</t>
<t>The 802.15.4 long address of this node.
</t>
<t>This property is only present on NCPs which implement 802.15.4
</t>
</section>

<section anchor="prop-mac-15-4-saddr" title="PROP 53: PROP_MAC_15_4_SADDR">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: <spanx style="strong">ONLY</spanx> when used with 802.15.4 MAC</t>
<t>Post-Reset Value: 0xFFFF</t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">2</ttcol>

<c>Format:</c><c>UINT16_LE</c>
<c>Fields:</c><c>SADDR</c>
</texttable>
<t>TODO(RQ): Break this out into an 802.15.4-specific section
</t>
<t>The 802.15.4 short address of this node.
</t>
<t>This property is only present on NCPs which implement 802.15.4
</t>
</section>

<section anchor="prop-mac-15-4-panid" title="PROP 54: PROP_MAC_15_4_PANID">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: <spanx style="strong">ONLY</spanx> when used with 802.15.4 MAC</t>
<t>Post-Reset Value: 0xFFFF ?</t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">2</ttcol>

<c>Format:</c><c>UINT16_LE</c>
<c>Fields:</c><c>PANID</c>
</texttable>
<t>TODO(RQ): Break this out into an 802.15.4-specific section
</t>
<t>The 802.15.4 PANID this node is associated with.
</t>
<t>This property is only present on NCPs which implement 802.15.4
</t>
</section>

<section anchor="prop-mac-raw-stream-enabled" title="PROP 55: PROP_MAC_RAW_STREAM_ENABLED">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: RECOMMENDED</t>
<t>Post-Reset Value: 0 (false)</t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c>RAW_STREAM_ENABLED</c>
</texttable>
<t>Set to true to enable raw MAC frames to be emitted from <spanx style="verb">PROP_STREAM_RAW</spanx>.
See <xref target="prop-stream-raw"/>.
</t>
</section>

<section anchor="prop-mac-promiscuous-mode" title="PROP 56: PROP_MAC_PROMISCUOUS_MODE">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: RECOMMENDED</t>
<t>Unit: Enumeration</t>
<t>Post-Reset Value: <spanx style="verb">MAC_PROMISCUOUS_MODE_OFF</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UINT8</c>
<c>Fields:</c><c>MAC_PROMISCUOUS_MODE</c>
</texttable>
<t>Possible Values:
</t>
<texttable>
<ttcol align="center">Id</ttcol>
<ttcol align="center">Name</ttcol>
<ttcol align="center">Description</ttcol>

<c>0</c><c><spanx style="verb">MAC_PROMISCUOUS_MODE_OFF</spanx></c><c>Normal MAC filtering is in place.</c>
<c>1</c><c><spanx style="verb">MAC_PROMISCUOUS_MODE_NETWORK</spanx></c><c>All MAC packets matching network are passed up the stack.</c>
<c>2</c><c><spanx style="verb">MAC_PROMISCUOUS_MODE_FULL</spanx></c><c>All decoded MAC packets are passed up the stack.</c>
</texttable>
<t>See <xref target="prop-stream-raw"/>.
</t>
</section>

<section anchor="prop-mac-escan-result" title="PROP 57: PROP_MAC_ENERGY_SCAN_RESULT">
<t>
<list style="symbols">
<t>Type: Packet Stream, Output-Only</t>
<t>Required: REQUIRED</t>
</list>
</t>
<t>Bytes: | 1 | 1
--------|----|-
Format: | UINT8 | INT8
Fields: | CHANNEL | RSSI
</t>
<t>This property is emitted during energy scan operation (SCAN_STATE_ENERGY)
once per scanned channel.
</t>
<t>The RSSI is measured in dB.
The specific meaning of zero dB is implementation-specific,
but MUST be consistant with definitions of other properties
that express power. It is RECOMMENDED that zero dB
represent one milliwatt of power (0dBm), as measured from the
antenna connector.
</t>
</section>

<section anchor="prop-mac-data-poll-period" title="PROP 58: PROP_MAC_DATA_POLL_PERIOD">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Unit: milliseconds</t>
<t>Post-Reset Value: 5000ms</t>
<t>Required Capability: <spanx style="verb">CAP_POWER_SAVE</spanx></t>
<t>See Also: <xref target="prop-power-state"/></t>
</list>
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UINT32_LE</c>
<c>Fields:</c><c>MAC_DATA_POLL_PERIOD</c>
</texttable>
<t>The (user-specified) data poll (802.15.4 MAC Data Request) period
in milliseconds. Value zero means the poll period will be calculated
by the stack to be the maximum interval acceptable by the parent. If the
maximum poll interval is longer than the maximum interval acceptable
by the parent, the later value is used instead.
</t>
<t>The value of this property is only used if <spanx style="verb">PROP_POWER_STATE</spanx> is set to
<spanx style="verb">POWER_STATE_LOW_POWER</spanx>. In all other states, the value of this property is
ignored.
</t>
<t>This property is only used on NCPs which support <spanx style="verb">POWER_STATE_LOW_POWER</spanx>.
</t>
</section>

<section anchor="prop-mac-whitelist" title="PROP 4864: PROP_MAC_WHITELIST">
<t>
<list style="symbols">
<t>Type: Multi-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Per-Item Length: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: empty</t>
<t>Required Capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
<t>See Also: <xref target="prop-mac-whitelist-enabled"/></t>
</list>
</t>
<t>TODO(RQ): Consider moving this to the debug section.
</t>
<t>When whitelisting is enabled, this property prevents the device from being able
to communicate with devices which are not in this list. Also, if the
RSSI field is not 127, the given RSSI value will always be reported
instead of using the RSSI from the radio hardware.
</t>
<t>This property is intended to facilitate stack testing and debugging
and SHOULD NOT be used in production.
</t>
<t>Item Format:
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">8</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>EUI-64-BE</c><c>UINT8</c>
<c>Fields:</c><c>ADDR</c><c>RSSI</c>
</texttable>
<t>
<list style="hanging">
<t hangText="ADDR">
<vspace />
EUI64 address of node</t>
<t hangText="RSSI">
<vspace />
Optional RSSI-override value. The value 127 indicates
   that the RSSI-override feature is not enabled for this
   address. If this value is omitted when setting or
   inserting, it is assumed to be 127. This parameter is
   ignored when removing and may be omitted.</t>
</list>
</t>
</section>

<section anchor="prop-mac-whitelist-enabled" title="PROP 4865: PROP_MAC_WHITELIST_ENABLED">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: 0 (false)</t>
<t>Required capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
<t>See Also: <xref target="prop-mac-whitelist"/></t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c><spanx style="verb">WHITELIST_ENABLED</spanx></c>
</texttable>
<t>TODO(RQ): Consider moving this to the debug section.
</t>
<t>Setting this to true SHALL cause <spanx style="verb">PROP_MAC_BLACKLIST_ENABLED</spanx> to be automatically
set to false.
</t>
</section>

<section anchor="prop-mac-src-match-enabled" title="PROP 4867: PROP_MAC_SRC_MATCH_ENABLED">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: 0 (false)</t>
<t>Required capability: <spanx style="verb">CAP_MAC_RAW</spanx>, TODO: 802.15.4 PHY CAP</t>
<t>See Also: <xref target="prop-mac-src-match-short-addresses"/>, <xref target="prop-mac-src-match-extended-addresses"/></t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c><spanx style="verb">SRC_MATCH_ENABLED</spanx></c>
</texttable>
<t>Set to true to enable radio source matching or false to disable it. The source match
functionality is used by radios when generating ACKs. The short and extended address
lists are used for settings the Frame Pending bit in the ACKs.
</t>
</section>

<section anchor="prop-mac-src-match-short-addresses" title="PROP 4868: PROP_MAC_SRC_MATCH_SHORT_ADDRESSES">
<t>
<list style="symbols">
<t>Type: Multi-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Per-Item Length: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: empty</t>
<t>Required Capability: <spanx style="verb">CAP_MAC_RAW</spanx>, TODO: 802.15.4 PHY CAP</t>
<t>See Also: <xref target="prop-mac-src-match-enabled"/></t>
</list>
</t>
<t>Configures the list of short addresses used for source matching. These
short address are used for hardware generated ACKs.
</t>
<t>Item Format:
</t>
<texttable>
<ttcol align="center">Bytes:</ttcol>
<ttcol align="center">2</ttcol>

<c>Format:</c><c>UINT16_LE</c>
<c>Fields:</c><c>SADDR</c>
</texttable>
</section>

<section anchor="prop-mac-src-match-extended-addresses" title="PROP 4869: PROP_MAC_SRC_MATCH_EXTENDED_ADDRESSES">
<t>
<list style="symbols">
<t>Type: Multi-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Per-Item Length: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: empty</t>
<t>Required Capabilities: <spanx style="verb">CAP_MAC_RAW</spanx>, TODO: 802.15.4 PHY CAP</t>
<t>See Also: <xref target="prop-mac-src-match-enabled"/></t>
</list>
</t>
<t>Configures the list of long addresses used for source matching. These
long address are used for hardware generated ACKs.
</t>
</section>

<section anchor="prop-mac-blacklist" title="PROP 4870: PROP_MAC_BLACKLIST">
<t>
<list style="symbols">
<t>Type: Multi-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Per-Item Length: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: empty</t>
<t>Required Capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
<t>See Also: <xref target="prop-mac-blacklist-enabled"/></t>
</list>
</t>
<t>TODO(RQ): Consider moving this to the debug section.
</t>
<t>When blacklisting is enabled, this property prevents the device from being able
to communicate with devices which are in this list.
</t>
</section>

<section anchor="prop-mac-blacklist-enabled" title="PROP 4871: PROP_MAC_BLACKLIST_ENABLED">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: 0 (false)</t>
<t>Required capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
<t>See Also: <xref target="prop-mac-blacklist"/></t>
</list>
</t>
<t>TODO(RQ): Consider moving this to the debug section.
</t>
<t>Setting this to true SHALL cause <spanx style="verb">PROP_MAC_WHITELIST_ENABLED</spanx> to be automatically
set to false.
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c><spanx style="verb">BLACKLIST_ENABLED</spanx></c>
</texttable>
</section>
</section>

<section anchor="prop-net" title="NET Properties">

<section anchor="prop-net-if-up" title="PROP 65: PROP_NET_IF_UP">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: 0 (false)</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c><spanx style="verb">NET_IF_UP</spanx></c>
</texttable>
<t>Network interface up/down status. Non-zero (set to 1) indicates up, zero indicates down.
</t>
<t>Setting this to false implies also setting <spanx style="verb">PROP_NET_STACK_UP</spanx> to false.
</t>

<section anchor="relationship-with-propnetstackup" title="Relationship with PROP_NET_STACK_UP">
<t>EDITOR: the examples show that the order of operations to bring up a network interface is first set PROP_NET_IF_UP=TRUE, then PROP_NET_STACK_UP=TRUE. What does it mean when PROP_NET_IF_UP=TRUE and PROP_NET_STACK_UP=FALSE? Does the NLI matter in operations with the PROP_NET_STACK_UP property?
</t>
<t>RQ: PROP_NET_IF_UP=TRUE, PROP_NET_STACK_UP=FALSE is used for in-band commissioning.
It bring up link-local IPv6 capabilities on PROP_STREAM_NET_INSECURE.
</t>
</section>
</section>

<section anchor="prop-net-stack-up" title="PROP 66: PROP_NET_STACK_UP">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED</t>
<t>Post-Reset Value: 0 (false)</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c><spanx style="verb">NET_STACK_UP</spanx></c>
</texttable>
<t>Network protocol stack operational status. Non-zero (set to 1) indicates up, zero indicates down.
</t>
<t>Setting this to true implies also setting <spanx style="verb">PROP_NET_IF_UP</spanx> to true.
</t>
</section>

<section anchor="prop-net-role" title="PROP 67: PROP_NET_ROLE">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Only*</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED</t>
<t>Unit: Enumeration</t>
<t>Post-Reset Value: 0 (<spanx style="verb">NET_ROLE_DETACHED</spanx>)</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UINT8</c>
<c>Fields:</c><c><spanx style="verb">NET_ROLE</spanx></c>
</texttable>
<t>Indicates what role the current device is playing on the network. This property is
read-only, with the exception that the AP can indicate that it wants the NCP to
detach and then attempt to reattach by setting this property to <spanx style="verb">NET_ROLE_DETACHED</spanx>
when it was previously set to another value. Attempting to set this property
to any other value will result in <spanx style="verb">STATUS_INVALID_ARGUMENT</spanx> being emitted.
</t>
<texttable>
<ttcol align="center">Code</ttcol>
<ttcol align="center">Name</ttcol>

<c>0</c><c><spanx style="verb">NET_ROLE_DETACHED</spanx></c>
<c>1</c><c><spanx style="verb">NET_ROLE_CHILD</spanx></c>
<c>2</c><c><spanx style="verb">NET_ROLE_ROUTER</spanx></c>
<c>3</c><c><spanx style="verb">NET_ROLE_LEADER</spanx></c>
<c>4</c><c><spanx style="verb">NET_ROLE_PEER</spanx></c>
</texttable>
<t>
<list style="hanging">
<t hangText="NET_ROLE_DETACHED">
<vspace />
The NCP is not currently participating on a network, or is in the process of attaching
to a network.</t>
<t hangText="NET_ROLE_CHILD">
<vspace />
The NCP is currently attached to the mesh network as a child to a router node. Communication
with nodes more than one hop away is possible. The NCP does not route any mesh traffic on the
behalf of other nodes.</t>
<t hangText="NET_ROLE_ROUTER">
<vspace />
The NCP is currently a router node on the network, and will transparently route mesh
traffic on behalf of other nodes.</t>
<t hangText="NET_ROLE_LEADER">
<vspace />
This role is identical ot <spanx style="verb">NET_ROLE_ROUTER</spanx> except that there is only node designated as the
leader per partition. This role is Thread-specific.</t>
<t hangText="NET_ROLE_PEER">
<vspace />
In this role, the NCP may communicate with nodes which are no more than one hop away. This
role is used while obtaining the network provision during in-band commissioning.</t>
</list>
</t>
</section>

<section anchor="prop-net-network-name" title="PROP 68: PROP_NET_NETWORK_NAME">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED for standard network layer</t>
<t>Post-Reset Value: Empty</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>UTF8</c><c>CONST</c>
<c>Fields:</c><c><spanx style="verb">NETWORK_NAME</spanx></c><c>0x00</c>
</texttable>
<t>Contains a zero-terminated UTF8 string which describes the name of
the current network. This is analogous to the SSID in 802.11. The maximum
length of the string is technology specific. Setting this property to a value
that is too large will cause <spanx style="verb">STATUS_PROP_VALUE_TOO_BIG</spanx> to be emitted.
</t>
<t>When this value is being retrieved, all trailing zero bytes in the network name
MUST be stripped. When this value is being set, all trailing zero bytes
SHOULD be stripped.
</t>
<t>See <xref target="security-network-name"/> for security considerations regarding UTF8
normalization.
</t>
</section>

<section anchor="prop-net-xpanid" title="PROP 69: PROP_NET_XPANID">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED for standard network layer</t>
<t>Post-Reset Value: All zeros</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">8</ttcol>

<c>Format:</c><c>XPANID</c>
<c>Fields:</c><c><spanx style="verb">NET_XPANID</spanx></c>
</texttable>
<t>Contains the extended personal-area network identifier for the current
network. It allows for different networks with identical names to not
conflict with each other. It is defined to be eight bytes long.
</t>
<t>For network technologies which don't have the concept of an XPANID,
this property is hard-coded to always be all zeros.
</t>
</section>

<section anchor="prop-net-master-key" title="PROP 70: PROP_NET_MASTER_KEY">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: REQUIRED for standard network layer</t>
<t>Post-Reset Value: Unspecified</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">n</ttcol>

<c>Format:</c><c>DATA</c>
<c>Fields:</c><c><spanx style="verb">NET_MASTER_KEY</spanx></c>
</texttable>
<t>Master key material. The exact length of the value for this property is defined by
the technology, but is generally 16-bytes (128-bit).
</t>
</section>

<section anchor="prop-net-key-sequence-counter" title="PROP 71: PROP_NET_KEY_SEQUENCE_COUNTER">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: No</t>
<t>Required: REQUIRED for standard network layer</t>
<t>Post-Reset Value: 0</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">4</ttcol>

<c>Format:</c><c>UINT32</c>
<c>Fields:</c><c><spanx style="verb">NET_KEY_SEQUENCE_COUNTER</spanx></c>
</texttable>
</section>

<section anchor="prop-net-partition-id" title="PROP 72: PROP_NET_PARTITION_ID">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Only</t>
<t>Asynchronous Updates: Yes</t>
<t>Required: OPTIONAL</t>
<t>Post-Reset Value: Unspecified</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">4</ttcol>

<c>Format:</c><c>UINT32</c>
<c>Fields:</c><c><spanx style="verb">NET_PARTITION_ID</spanx></c>
</texttable>
<t>The partition ID of the partition that this node is a member of.
</t>
<t>For network technologies which don't have the concept of a partition id,
this property is hard-coded to always be zero.
</t>
</section>

<section anchor="prop-net-require-join-existing" title="PROP 73: PROP_NET_REQUIRE_JOIN_EXISTING">
<t>
<list style="symbols">
<t>Type: Single-Value, Read-Write</t>
<t>Asynchronous Updates: Yes</t>
<t>Required:
<list style="symbols">
<t>Read: OPTIONAL</t>
<t>Write: REQUIRED</t>
</list></t>
<t>Post-Reset Value: 0 (false)</t>
</list>
</t>
<texttable>
<ttcol align="right">Bytes:</ttcol>
<ttcol align="center">1</ttcol>

<c>Format:</c><c>BOOL</c>
<c>Fields:</c><c><spanx style="verb">NET_REQUIRE_JOIN_EXISTING</spanx></c>
</texttable>
<t><cref source="RQ">TODO: Elaborate on PROP_NET_JOIN_EXISTING --</cref></t>
</section>

<section anchor="prop-net-key-swtich-guardtime" title="PROP 74: PROP_NET_KEY_SWITCH_GUARDTIME">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx></t>
</list>
</t>
<t><cref source="RQ">TODO: This likely doesn't belong in core, at least not in the small-number section.  --</cref></t>
</section>

<section anchor="prop-net-pskc" title="PROP 75: PROP_NET_PSKC">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
<t><cref source="RQ">TODO: This likely doesn't belong in core, at least not in the small-number section.  --</cref></t>
</section>
</section>

<section anchor="prop-ipv6" title="IPv6 Properties">

<section anchor="prop-ipv6-ll-addr" title="PROP 96: PROP_IPV6_LL_ADDR">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">6</spanx></t>
</list>
</t>
<t>The IPv6 link-local scope address.
</t>
</section>

<section anchor="prop-ipv6-address-table" title="PROP 99: PROP_IPV6_ADDRESS_TABLE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(t(6CLLC))</spanx></t>
</list>
</t>
<t>This property provides all unicast addresses.
Array of structures containing:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">6</spanx>: IPv6 Address</t>
<t><spanx style="verb">C</spanx>: Network Prefix Length</t>
<t><spanx style="verb">L</spanx>: Valid Lifetime</t>
<t><spanx style="verb">L</spanx>: Preferred Lifetime</t>
<t><spanx style="verb">C</spanx>: Flags</t>
</list>
</t>
<t>EDITOR: this conflates the IPv6 interface address list with the IPv6 on-link prefix used in IPv6 Neighbor Discovery and other address reservation and resolution protocols with similar function, e.g. Thread(R). It probably makes sense to create an additional set of properties that represent neighbor discovery and router discovery parameters.
</t>
<t>EDITOR: the operational semantics of the Flags field is not well-specified.
</t>
</section>

<section anchor="prop-101-propipv6icmppingoffload" title="PROP 101: PROP_IPv6_ICMP_PING_OFFLOAD">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Allow the NCP to directly respond to ICMP ping requests. If this is turned on, ICMP echo request packets will not be passed to the OS.
</t>
<t>Default value is <spanx style="verb">false</spanx>.
</t>
</section>

<section anchor="prop-ipv6-multicast-address-table" title="PROP 102: SPINEL_PROP_IPV6_MULTICAST_ADDRESS_TABLE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(t(6))</spanx></t>
</list>
</t>
<t>Array of structures containing:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">6</spanx>: Multicast IPv6 Address</t>
</list>
</t>
</section>
</section>

<section anchor="prop-debug" title="Debug Properties">

<section anchor="prop-debug-test-assert" title="PROP 16384: PROP_DEBUG_TEST_ASSERT">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Reading this property will cause an assert on the NCP. This is intended for testing the assert functionality of underlying platform/NCP. Assert should ideally cause the NCP to reset, but if <spanx style="verb">assert</spanx> is not supported or disabled boolean value of <spanx style="verb">false</spanx> is returned in response.
</t>
</section>

<section anchor="prop-debug-ncp-log-level" title="PROP 16385: PROP_DEBUG_NCP_LOG_LEVEL">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>Provides access to the NCP log level. Standard log level codes, which are derived from <xref target="RFC5424"/>, are shown below:
</t>
<t>
<list style="symbols">
<t>0: Emergency (emerg).</t>
<t>1: Alert (alert).</t>
<t>2: Critical (crit).</t>
<t>3: Error (err).</t>
<t>4: Warning (warn).</t>
<t>5: Notice (notice).</t>
<t>6: Information (info).</t>
<t>7: Debug (debug).</t>
</list>
</t>
<t>If the NCP supports dynamic log level control, setting this property changes the log level accordingly. Getting the value returns the current log level.  If the dynamic log level control is not supported, setting this property returns a <spanx style="verb">PROP_LAST_STATUS</spanx> with <spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx>.
</t>
</section>
</section>
</section>

<section anchor="security-considerations" title="Security Considerations">
<t>EDITOR: Insert verbiage here conforming to RFC Editor guidelines.
</t>

<section anchor="security-network-name" title="Network Name Normalization">
<t>TODO: Discuss UTF8 verification and normalization considerations related to
<spanx style="verb">PROP_NET_NETWORK_NAME</spanx>.
</t>
</section>

<section anchor="raw-application-access" title="Raw Application Access">
<t>Spinel MAY be used as an API boundary for allowing processes to configure the NCP. However, such a system MUST NOT give unprivileged processess the ability to send or receive arbitrary command frames to the NCP. Only the specific commands and properties that are required should be allowed to be passed, and then only after being checked for proper format.
</t>
</section>
</section>

<section anchor="iana-considerations" title="IANA Considerations">
<t>EDITOR: insert verbiage here: registry creation forms, et cetera.
</t>
<t>

</t>
</section>

</middle>
<back>
<references title="Normative References">
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"?>
</references>
<references title="Informative References">
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-bormann-t2trg-slipmux-01.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1055.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2360.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5424.xml"?>
</references>

<section anchor="example-sessions" title="Example Sessions">

<section anchor="ncp-initialization" title="NCP Initialization">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>Check the protocol version to see if it is supported:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_PROTOCOL_VERSION</t>
<t>CMD_VALUE_IS:PROP_PROTOCOL_VERSION</t>
</list>
</t>
<t>Check the NCP version to see if a firmware update may be necessary:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_NCP_VERSION</t>
<t>CMD_VALUE_IS:PROP_NCP_VERSION</t>
</list>
</t>
<t>Check interface type to make sure that it is what we expect:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_INTERFACE_TYPE</t>
<t>CMD_VALUE_IS:PROP_INTERFACE_TYPE</t>
</list>
</t>
<t>If the OS supports using vendor-specific commands, the vendor should be verified before using them:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_VENDOR_ID</t>
<t>CMD_VALUE_IS:PROP_VENDOR_ID</t>
</list>
</t>
<t>Fetch the capability list so that we know what features this NCP supports:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_CAPS</t>
<t>CMD_VALUE_IS:PROP_CAPS</t>
</list>
</t>
<t>If the NCP supports CAP_NET_SAVE, then we go ahead and recall the network:
</t>
<t>
<list style="symbols">
<t>CMD_NET_RECALL</t>
</list>
</t>
</section>

<section anchor="attaching-to-a-network" title="Attaching to a network">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>We make the assumption that the NCP is already associated with a network at physical and media access layers. The core layer steps proceed after the initial phase of initializing the specific network layer stack.
</t>
<t>Bring the network interface up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_IF_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_IF_UP:TRUE</t>
</list>
</t>
<t>Bring the routing stack up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_STACK_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:TRUE</t>
</list>
</t>
</section>

<section anchor="detaching-from-a-network" title="Detaching from a network">
<t>This is the reverse of the previous case.
</t>
<t>Bring the routing stack up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_STACK_UP:FALSE</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:FALSE</t>
</list>
</t>
<t>Bring the network interface up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_IF_UP:FALSE</t>
<t>CMD_VALUE_IS:PROP_NET_IF_UP:FALSE</t>
</list>
</t>
</section>

<section anchor="attaching-to-a-saved-network" title="Attaching to a saved network">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>Recall the saved network if you haven't already done so:
</t>
<t>
<list style="symbols">
<t>CMD_NET_RECALL</t>
</list>
</t>
<t>Bring the network interface up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_IF_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_IF_UP:TRUE</t>
</list>
</t>
<t>Bring the routing stack up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_STACK_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:TRUE</t>
</list>
</t>
</section>

<section anchor="ncp-software-reset" title="NCP Software Reset">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>
<list style="symbols">
<t>CMD_RESET</t>
<t>CMD_VALUE_IS:PROP_LAST_STATUS:STATUS_RESET_SOFTWARE</t>
</list>
</t>
<t>Then jump to <xref target="ncp-initialization"/>.
</t>
</section>
</section>

<section anchor="appendix-framing" title="Recommended Framing Protocols">
<t>Since this NCP protocol is defined independently of the physical transport or framing, any number of transports and framing protocols could be used successfully. However, in the interests of compatibility, this document provides some recommendations.
</t>

<section anchor="uart-recommendations" title="UART Recommendations">
<t>The recommended default UART settings are:
</t>
<t>
<list style="symbols">
<t>Bit rate:     115200</t>
<t>Start bits:   1</t>
<t>Data bits:    8</t>
<t>Stop bits:    1</t>
<t>Parity:       None</t>
<t>Flow Control: Hardware</t>
</list>
</t>
<t>These values may be adjusted depending on the individual needs of the application or product, but some sort of flow control MUST be used. Hardware flow control is preferred over software flow control. In the absence of hardware flow control, software flow control (XON/XOFF) MUST be used instead.
</t>
<t>We also <spanx style="strong">RECOMMEND</spanx> an Arduino-style hardware reset, where the DTR signal is coupled to the <spanx style="verb">RES</spanx> pin through a 0.01 micro-Farad capacitor. This causes the NCP to automatically reset whenever the serial port is opened. At the very least we <spanx style="strong">RECOMMEND</spanx> dedicating one of your OS host pins to controlling the <spanx style="verb">RES</spanx> pin on the NCP, so that you can easily perform a hardware reset if necessary.
</t>

<section anchor="uart-bit-rate-detection" title="UART Bit Rate Detection">
<t>When using a UART, the issue of an appropriate bit rate must be considered. 115200 bits/s is the conventional baud rate for many serial peripherals. This rate, however, is slower than the theoretical maximum bitrate of many relevant network interfaces, e.g. the 802.15.4 2.4GHz PHY (250kbit). In most circumstances this mismatch is not significant because the overall bitrate will be much lower than either of these rates, but there are circumstances where a faster UART bitrate is desirable. Thus, this document proposes a simple bitrate detection scheme that can be employed by the OS to detect when the attached NCP is initially running at a higher bitrate.
</t>
<t>The algorithm is to send successive NOOP commands to the NCP at increasing bitrates. When a valid <spanx style="verb">CMD_LAST_STATUS</spanx> response has been received, we have identified the correct bitrate.
</t>
<t>In order to limit the time spent hunting for the appropriate bitrate, we RECOMMEND that only the following bitrates be checked:
</t>
<t>
<list style="symbols">
<t>115200</t>
<t>230400</t>
<t>1000000 (1Mbit)</t>
</list>
</t>
<t>The bitrate MAY also be changed programmatically by adjusting <spanx style="verb">PROP_UART_BITRATE</spanx>, if implemented.
</t>
</section>

<section anchor="hdlc-lite" title="HDLC-Lite">
<t><spanx style="emph">HDLC-Lite</spanx> is the recommended framing protocol for transmitting Spinel frames over a UART. HDLC-Lite consists of only the framing, escaping, and CRC parts of the larger HDLC protocol---all other parts of HDLC are omitted. This protocol was chosen because it works well with software flow control and is widely implemented.
</t>
<t>To transmit a frame with HDLC-lite, the 16-bit CRC must first be appended to the frame. The CRC function is defined to be CRC-16/CCITT, otherwise known as the <eref target="http://reveng.sourceforge.net/crc-catalogue/16.htm#crc.cat.kermit">KERMIT CRC</eref>.
</t>
<t>Individual frames are terminated with a frame delimiter octet called the 'flag' octet (<spanx style="verb">0x7E</spanx>).
</t>
<t>The following octets values are considered <spanx style="emph">special</spanx> and should be escaped when present in data frames:
</t>
<texttable>
<ttcol align="left">Octet Value</ttcol>
<ttcol align="left">Description</ttcol>

<c>0x7E</c><c>Frame Delimiter (Flag)</c>
<c>0x7D</c><c>Escape Byte</c>
<c>0x11</c><c>XON</c>
<c>0x13</c><c>XOFF</c>
<c>0xF8</c><c>Vendor-Specific</c>
</texttable>
<t>When present in a data frame, these octet values are escaped by prepending the escape octet (<spanx style="verb">0x7D</spanx>) and XORing the value with <spanx style="verb">0x20</spanx>.
</t>
<t>When receiving a frame, the CRC must be verified after the frame is unescaped. If the CRC value does not match what is calculated for the frame data, the frame MUST be discarded. The implementation MAY indicate the failure to higher levels to handle as they see fit, but MUST NOT attempt to process the deceived frame.
</t>
<t>Consecutive flag octets are entirely legal and MUST NOT be treated as a framing error. Consecutive flag octets MAY be used as a way to wake up a sleeping NCP.
</t>
<t>When first establishing a connection to the NCP, it is customary to send one or more flag octets to ensure that any previously received data is discarded.
</t>
</section>
</section>

<section anchor="spi-recommendations" title="SPI Recommendations">
<t>We <spanx style="strong">RECOMMEND</spanx> the use of the following standard SPI signals:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CS</spanx>:   (OS-to-NCP) Chip Select</t>
<t><spanx style="verb">CLK</spanx>:  (OS-to-NCP) Clock</t>
<t><spanx style="verb">MOSI</spanx>: Master-Output/Slave-Input</t>
<t><spanx style="verb">MISO</spanx>: Master-Input/Slave-Output</t>
<t><spanx style="verb">INT</spanx>:  (NCP-to-OS) Host Interrupt</t>
<t><spanx style="verb">RES</spanx>:  (OS-to-NCP) NCP Hardware Reset</t>
</list>
</t>
<t>The <spanx style="verb">INT</spanx> signal is used by the NCP to indicate to the OS that the NCP has frames pending to send to it. When asserted, the OS SHOULD initiate a SPI transaction in a timely manner.
</t>
<t>We RECOMMEND the following SPI properties:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CS</spanx> is active low.</t>
<t><spanx style="verb">CLK</spanx> is active high.</t>
<t><spanx style="verb">CLK</spanx> speed is larger than 500 kHz.</t>
<t>Data is valid on leading edge of <spanx style="verb">CLK</spanx>.</t>
<t>Data is sent in multiples of 8-bits (octets).</t>
<t>Octets are sent most-significant bit first.</t>
</list>
</t>
<t>This recommended configuration may be adjusted depending on the individual needs of the application or product.
</t>

<section anchor="spi-framing-protocol" title="SPI Framing Protocol">
<t>Each SPI frame starts with a 5-byte frame header:
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">2</ttcol>

<c>Fields:</c><c>HDR</c><c>RECV_LEN</c><c>DATA_LEN</c>
</texttable>
<t>
<list style="symbols">
<t><spanx style="verb">HDR</spanx>: The first byte is the header byte (defined below)</t>
<t><spanx style="verb">RECV_LEN</spanx>: The second and third bytes indicate the largest frame size that that device is ready to receive. If zero, then the other device must not send any data. (Little endian)</t>
<t><spanx style="verb">DATA_LEN</spanx>: The fourth and fifth bytes indicate the size of the pending data frame to be sent to the other device. If this value is equal-to or less-than the number of bytes that the other device is willing to receive, then the data of the frame is immediately after the header. (Little Endian)</t>
</list>
</t>
<t>The <spanx style="verb">HDR</spanx> byte is defined as:
</t>

<figure align="center"><artwork align="center">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|RST|CRC|CCF|  RESERVED |PATTERN|
+---+---+---+---+---+---+---+---+
</artwork></figure>
<t>
<list style="symbols">
<t><spanx style="verb">RST</spanx>: This bit is set when that device has been reset since the last time <spanx style="verb">CS</spanx> was asserted.</t>
<t><spanx style="verb">CRC</spanx>: This bit is set when that device supports writing a 16-bit CRC at the end of the data. The CRC length is NOT included in DATA_LEN.</t>
<t><spanx style="verb">CCF</spanx>: &quot;CRC Check Failure&quot;. Set if the CRC check on the last received frame failed, cleared to zero otherwise. This bit is only used if both sides support CRC.</t>
<t><spanx style="verb">RESERVED</spanx>: These bits are all reserved for future used. They MUST be cleared to zero and MUST be ignored if set.</t>
<t><spanx style="verb">PATTERN</spanx>: These bits are set to a fixed value to help distinguish valid SPI frames from garbage (by explicitly making <spanx style="verb">0xFF</spanx> and <spanx style="verb">0x00</spanx> invalid values). Bit 6 MUST be set to be one and bit 7 MUST be cleared (0). A frame received that has any other values for these bits MUST be dropped.</t>
</list>
</t>
<t>Prior to a sending or receiving a frame, the master MAY send a 5-octet frame with zeros for both the max receive frame size and the the contained frame length. This will induce the slave device to indicate the length of the frame it wants to send (if any) and indicate the largest frame it is capable of receiving at the moment. This allows the master to calculate the size of the next transaction. Alternatively, if the master has a frame to send it can just go ahead and send a frame of that length and determine if the frame was accepted by checking that the <spanx style="verb">RECV_LEN</spanx> from the slave frame is larger than the frame the master just tried to send. If the <spanx style="verb">RECV_LEN</spanx> is smaller then the frame wasn't accepted and will need to be transmitted again.
</t>
<t>This protocol can be used either unidirectionally or bidirectionally, determined by the behavior of the master and the slave.
</t>
<t>If the the master notices <spanx style="verb">PATTERN</spanx> is not set correctly, the master should consider the transaction to have failed and try again after 10 milliseconds, retrying up to 200 times. After unsuccessfully trying 200 times in a row, the master MAY take appropriate remedial action (like a NCP hardware reset, or indicating a communication failure to a user interface).
</t>
<t>At the end of the data of a frame is an optional 16-bit CRC, support for which is indicated by the <spanx style="verb">CRC</spanx> bit of the <spanx style="verb">HDR</spanx> byte being set. If these bits are set for both the master and slave frames, then CRC checking is enabled on both sides, effectively requiring that frame sizes be two bytes longer than would be otherwise required. The CRC is calculated using the same mechanism used for the CRC calculation in HDLC-Lite (See <xref target="hdlc-lite"/>). When both of the <spanx style="verb">CRC</spanx> bits are set, both sides must verify that the <spanx style="verb">CRC</spanx> is valid before accepting the frame. If not enough bytes were clocked out for the CRC to be read, then the frame must be ignored. If enough bytes were clocked out to perform a CRC check, but the CRC check fails, then the frame must be rejected and the <spanx style="verb">CRC_FAIL</spanx> bit on the next frame (and ONLY the next frame) MUST be set.
</t>
</section>
</section>

<section anchor="i2c-recommendations" title="I2C Recommendations">
<t>TBD
</t>
<t><cref source="RQ">It may make sense to have a look at what Bluetooth HCI is doing
     for native I2C framing and go with that.</cref></t>
</section>

<section anchor="native-usb-recommendations" title="Native USB Recommendations">
<t>TBD
</t>
<t><cref source="RQ">It may make sense to have a look at what Bluetooth HCI is doing
     for native USB framing and go with that.</cref></t>
</section>
</section>

<section anchor="test-vectors" title="Test Vectors">

<section anchor="test-vector-packed-unsigned-integer" title="Test Vector: Packed Unsigned Integer">
<texttable>
<ttcol align="right">Decimal Value</ttcol>
<ttcol align="left">Packet Octet Encoding</ttcol>

<c>0</c><c><spanx style="verb">00</spanx></c>
<c>1</c><c><spanx style="verb">01</spanx></c>
<c>127</c><c><spanx style="verb">7F</spanx></c>
<c>128</c><c><spanx style="verb">80 01</spanx></c>
<c>129</c><c><spanx style="verb">81 01</spanx></c>
<c>1,337</c><c><spanx style="verb">B9 0A</spanx></c>
<c>16,383</c><c><spanx style="verb">FF 7F</spanx></c>
<c>16,384</c><c><spanx style="verb">80 80 01</spanx></c>
<c>16,385</c><c><spanx style="verb">81 80 01</spanx></c>
<c>2,097,151</c><c><spanx style="verb">FF FF 7F</spanx></c>
</texttable>
<t><cref source="RQ">The PUI test-vector encodings need to be verified.</cref></t>
</section>

<section anchor="test-vector-reset-command" title="Test Vector: Reset Command">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 0</t>
<t>CMD: 1 (<spanx style="verb">CMD_RESET</spanx>)</t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
80 01
</artwork></figure>
</section>

<section anchor="test-vector-reset-notification" title="Test Vector: Reset Notification">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 0</t>
<t>CMD: 6 (<spanx style="verb">CMD_VALUE_IS</spanx>)</t>
<t>PROP: 0 (<spanx style="verb">PROP_LAST_STATUS</spanx>)</t>
<t>VALUE: 114 (<spanx style="verb">STATUS_RESET_SOFTWARE</spanx>)</t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
80 06 00 72
</artwork></figure>
</section>

<section anchor="test-vector-inbound-ipv6-packet" title="Test Vector: Inbound IPv6 Packet">
<t>CMD_VALUE_IS(PROP_STREAM_NET)
</t>
<t><cref source="RQ">FIXME: This test vector is incomplete.</cref></t>
</section>

<section anchor="test-vector-outbound-ipv6-packet" title="Test Vector: Outbound IPv6 Packet">
<t>CMD_VALUE_SET(PROP_STREAM_NET)
</t>
<t><cref source="RQ">FIXME: This test vector is incomplete.</cref></t>
</section>
</section>

<section anchor="appendix-comparison" title="Comparison with other protocols">
<t>The problem of needing to manage a connectivity peripheral attached to
a general-purpose computer is not new. The Hayes Command Set
(TODO:CITE), for example, has been in use since 1981 and quickly
became a ubiquitous de-facto standard for configuring dial-up modems
and other similar peripherals. In more recent times, the standardized
Bluetooth HCI protocol (TODO:CITE) helps to ensure plug-and-play
interoperability between the operating system and the Bluetooth
peripheral.
</t>
<t>IEEE 802.15.4 (TODO:CITE) based low-power wireless networks are
quickly becoming ubiquitous, and with the introduction of 6LoWPAN
(<xref target="RFC4944"/>), IPv6 connectivity is now possible on these networks.
6LoWPAN-based network technologies such as Thread(R) and ZigBee(R) IP
additionally provide additional features such as network security,
mesh-networking, and ultra-low-power operation. To fully realize
low-power operation, a great deal of the IPv6 network and routing
stack needs to be implemented directly on the connectivity peripheral.
With that, we again find ourselves with a question of how best to
communicate with and manage this new class of peripheral.
There have been a wide range of solutions to this problem, each with
significant drawbacks:
</t>
<t>
<list style="symbols">
<t>Using SLIP (<xref target="RFC1055"/>)
<list style="symbols">
<t>UART-only</t>
<t>Management must be handled out-of-band</t>
<t>Widely supported</t>
</list></t>
<t>Using slipmux (<xref target="I-D.bormann-t2trg-slipmux"/>)
<list style="symbols">
<t>UART-only</t>
<t>Management in-band, but is managed using CoAP. Exact details
of management protocol are not specified.</t>
<t>Backward compatible with existing SLIP implementations.</t>
</list></t>
<t>USB CDC-ECM for data, using some other USB protocol for management
(TODO:CITE)
<list style="symbols">
<t>USB-only</t>
<t>Somewhat Plug-and-play (appears as an ethernet device)</t>
<t>Mismatched network layer: CDC-ECM is layer-2, whereas IPv6 is
layer-3. This leads to the requirement of clever work-arounds
that can't satisfactorily handle all cases.</t>
<t>Bespoke, text-based management protocol</t>
</list></t>
<t>Proprietary protocols
<list style="symbols">
<t>Often covered by NDA</t>
<t>Not plug-and-play, can't easily swap parts with a different
vendor</t>
<t>Can change often and without warning</t>
</list></t>
</list>
</t>
<t>Standardized interfaces to specific classes of connectivity
peripherals significantly reduces the implementation and deployment
burdens. Bluetooth, for example, has standardized on the Bluetooth
HCI, which allows plug-and-play interoperability between Bluetooth
peripherals. Similar to Bluetooth HCI, Spinel is frame-based and
doesn't mandate the exact mechanism used to exchange frames between
the peripheral and the host. It does, however, make recommendations,
and we do likewise in <xref target="appendix-framing"/>.
</t>
<t>Note that, unlike PPP  or SLIP  (where the cable
is the network medium and the serial port of the network interface),
Spinel is not a link-layer network protocol between machines: it is an
extension of the IPv6 stack into an external network co-processor.
Spinel isn't used for directly communicating with another independent
host: it is instead used for communicating with an intermediary (the
NCP) who acts on the behalf of the application processor. The network
interface doesn't end at the serial port, rather it extends into the
NCP---which might not have it's own independent IPv6 address.
</t>
</section>

<section anchor="acknowledgments" title="Acknowledgments">
<t>Thread is a registered trademark of The Thread Group, Inc.
</t>
<t>Special thanks to Nick Banks, Jonathan Hui, Abtin Keshavarzian, Yakun Xu, Piotr Szkotak, Arjuna Sivasithambaresan and Martin Turon for their substantial contributions and feedback related to this document.
</t>
<t>This document was prepared using <eref target="https://github.com/miekg/mmark">mmark</eref> by (Miek Gieben) and <eref target="http://xml2rfc.ietf.org/">xml2rfc (version 2)</eref>.
</t>
</section>

</back>
</rfc>
